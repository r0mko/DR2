# +(@#$%&)_GSN/+ $Topic: diat $$Id: diat.dok 4.1.1.2 2012/02/24 07:17:52 pf Exp $

Версия 270398

Содержание







|















1.4  Задание на завершение диалога

С помощью следующей телеграммы DIATу выдается задание на завершение диалога в нормальном режиме:

ABDI < Имя диалога >

ABDI: Сокращение(аббревиатура) команды для 'Завершить диалог'.

< Имя диалога >: Название диалога, который требуется завершить. Если существует запущенный диалог с таким именем, то он прерывается вне зависимости от фазы или шага, на которых он находится. Пользователь уведомляется о выполнении завершения. Если прерываемый диалог запустил зависимые от него субдиалоги или же сам является таким зависимым субдиалогом другого диалога, то все зависимые диалоги и основной диалог прерываются вместе с ним.

Все диалоги пользователя(User) завершаются с помощью следующего задания:

ABAD < User >

ABAD: Сокращение(аббревиатура) команды для 'Завершить все диалоги'.

Последовательность BFM (монитор последовательности управляющих команд) завершается с помощью следующего задания:

ABFL < Имя диалога >

ABFL: Сокращение(аббревиатура) команды для 'Завершить последовательность'. Тогда последовательность будет во фрагменте ANWA.


1.5  Квитирование задания

Известные задания от внешних пользователей диалоговому инструментарию квитируются следующим способом, если может быть определен пользователь, сформировавший задание:

Полученное задание дополняется статусом выполнения и отправляется обратно пользователю, сформировавшему его.

Статус:
0       -> Безошибочное выполнение задания.
1       -> Ошибка формата
2       -> Диалог уже запущен
3       -> Слишком много диалогов
4       -> Файл не открывается
5       -> Синтаксическая ошибка в файле
6       -> Ошибка инициализации
7       -> Неизвестный идентификатор диалога
8       -> Неизвестное задание
9       -> Неизвестная фаза
10       -> Неизвестный набор данных
11       -> Неизвестный элемент данных

Следующие задания подлежат квитированию :

STDI PLDI SPDI APDI ABDI PHDI

1.6  Задание фазы диалога

Под фазой диалога подразумевается фрагмент диалога, который однократно получил данные и может выполняться DIATом самостоятельно и без использования дополнительных данных, полученных извне.

С помощью следующей телеграммы DIATу выдается задание покинуть текущую фазу диалога и начать новую вне зависимости от того, что необходимо сделать в текущей фазе диалога:

PHDI < Имя диалога > < Имя фазы >

PHDI: Сокращение(аббревиатура) команды для 'Задать фазу в диалоге'.

< Имя диалога >: Название диалога, который должен завершить свою текущую фазу и начать новую. Текущая фаза завершается немедленно без выполнения каких-либо действий с графическим интерфейсом и без отправки каких-либо данных пользователю, сформировавшему задание. Выполнение задания лишь квитируется.


< Имя фазы >: Название фазы диалога <Имя диалога>, которое следует принять безотлагательно. Имя может содержать до
16 символов. Если в файле управления диалогом отсутствует фаза с таким именем, то задание квитируется отрицательно.

1.7  Задание на работу с диалогом

Диалоговому инструметарию выдается задание сгенерировать какой-либо случай входных данных для диалога и передать его:

FADI < Dialogmatch > < Действие > < Строка >

< Dialogmatch >: Имя диалога может содержать символы-джокеры (Wildchars (*,?,[],{})), т.е. символы, использующиеся для замены других символов или их последовательностей. Различные случаи входных данных генерируется для всех подходящих (str_match) диалогов.

< Действие >: Сокращение(аббревиатура) действия, макс. 4 символа, которое должно быть приведено в секции "Ввод действия" для диалога, к которому производится обращение, если в него поступят входные данные, как в конкретном случае.

< Строка >: < ASCII_символы >

В строке находится символ < ` > , заменяющий символ ограничения строки < " >. В конце строки должен быть 0.

1.8  Задание на импорт данных

С помощью следующей телеграммы DIATу выдается задание на импорт массива с актуальными данными:

DADI < Имя диалога > < Имя набора данных > < Данные >

DADI: Сокращение(аббревиатура) команды для 'Импортировать набор данных для диалога'.

< Имя диалога >: Название диалога, который должен импортировать этот набор данных.

< Имя набора данных >: Название набора данных, который должен импортировать данные. Имя состоит макс. из 16 символов и 5 дополнительных символов для возможной индексации (набор данных, состоящий из векторов). Если в файле управления диалогом отсутствует набор данных с таким именем, то задание квитируется отрицательно и не выполняется.

< Данные >: Строка данных, соответствующая указанному формату данных. Данные преобразуются в соответствии с форматом данных. Данные каждого отдельного элемента данных начинаются с символа | и заканчиваются следующим  символом | или в конце строки. Лишнее содержимое элемента данных игнорируется, а слишком малое (т.е.недостаточное для изменения всех данных) - изменяет только те элементы данных, для которых хватит предложенного количества новых данных.

Импортированные данные перезаписывают данные указанного набора данных. Сразу после этого они становятся достоверными. Достоверность помечается значением 0 для каждого статуса элемента данных в наборе данных и в статусе набора данных. Для каждого перезаписанного элемента данных, а также для набора данных устанавливается флаг изменения.

Для случая синхронизированного получения данных используется следующая телеграмма:

DFDI < Dialogmatch > < Имя набора данных > < Данные >

DFDI: Сокращение(аббревиатура) команды для 'Импортировать набор данных (случай-синхронно) для диалога'.

< Dialogmatch >: Как для FADI

< Имя набора данных >: Как для DADI

< Данные >: Как для DADI

Сразу же после DFDI's должен быть отправлен FADI с тем же самым < Dialogmatch >.

1.9  Задание на достоверизацию элемента данных

С помощью следующей телеграммы DIATу выдается задание дополнить элемент данных актуальными метками достоверности, которые были определены пользователем, сформировавшим задание, в процессе достоверизации. При этом элемент данных может быть дополнительно исправлен:

PLDE < Имя диалога > < Имя набора данных >.< Имя элемента данных > | < Значение статуса > [ | < Исправленные данные > ]

PLDE: Сокращение(аббревиатура) команды для 'Достоверные данные для элемента данных'.

< Имя диалога >: Название диалога, который должен импортировать этот статус элемента данных.

< Имя набора данных >: Название набора данных, который содержит конкретный элемент данных. Имя может содержать макс. 21 символ. Если в файле управления диалогом отсутствует набор данных с таким именем, то задание квитируется отрицательно и не выполняется.

< Имя элемента данных >: Идентификатор элемента данных из списка элементов данных набора данных. Этому элементу данных назначается статус с актуальной достоверностью. Если в наборе данных отсутствует элемент данных с таким именем, то задание квитируется отрицательно и не выполняется.

< Значение статуса >: Целочисленное значение, обозначающее достоверность элемента данных. При этом
0 означает достоверность, а любое другое значение - какую-то специфическую ошибку.

< Исправленные данные >: Дополнительно, исправленные данные для элемента данных.


1.10  Задание на достоверизацию набора данных

С помощью следующей телеграммы DIATу выдается задание дополнить набор данных актуальными метками достоверности, которые были определены пользователем, сформировавшим задание, в процессе достоверизации.

PLDS < Имя диалога > < Имя набора данных > < Список значений статуса >

PLDS: Сокращение(аббревиатура) команды для 'Достоверные данные для набора данных'.

< Имя диалога >: Название диалога, который должен импортировать этот статус набора данных.

< Имя набора данных >: Название набора данных, который должен импортировать значения статуса. Имя может содержать макс. 21 символ. Если в файле управления диалогом отсутствует набор данных с таким именем, то задание квитируется отрицательно и не выполняется.

< Список значений статуса >: | < Значение статуса > | < Значение статуса > ...

< Значение статуса >: Целочисленное значение статуса. N-значений статуса обозначают соответствующий статус элемента данных в порядке следования элементов данных в наборе данных. Отсутствующие значения статуса оставляют прежний (т.е действующий до сих пор) статус соответствующих элементов данных, лишние значения игнорируются.

1.11  Файлы управления диалогом

Файл управления диалогом - это файл в формате ASCII (ASCII-File), соответствует следующим правилам наименования:

< Имя >.dsf

< Имя >: Имя файла, который подлежит ограничениям в зависимости от операционной системы. dsf - это сокращение для файла управления диалогом.

Благодаря дополнительному ключевому слову VERSION может быть считана строка версии файла управления диалогом для отображения в отладчике диалогов.

VERSION < Строка версии >

< Строка версии >: "< ASCII_символ >"

Файл управления диалогом содержит все необходимые указания для формального управления диалогом во всех его фазах. Последовательность фаз (т.е. их очерёдность) не описана в файле, управление этим осуществляется в программе пользователя, формирующего задания. Файл управления синтаксически подразделен на различные секции. Он начинается с помощью ключевого слова

BEGIN

и заканчивается ключевым словом

END.

Пример: BEGIN < Секция x > < Секция y > ... END

Каждая строка файла управления может быть дополнена комментарием, который начинается с помощью ключевого слова

** или /*

и заканчивается в конце строки. Согласно установленным правилам введенные с помощью /* комментарии завершаются в конце строки таким же символом.

Пример: ** Это комментарий. /* Это комментарий. */

Текстовая константа или строка формируется с помощью последовательности символов, заключенной в "" . Если строка должна быть переведена на иностранный язык, то это следует написать в следующей форме:

_Tr ("Поледовательность символов..").

Тогда перевод на установленный язык производится автоматически. Указания для переводчика могут быть размещены в строках до _Tr(..) в качестве комментария, т.е. начинаться и заканчиваться символами /*.

Синтаксически законченное понятие может располагаться на одной или нескольких строках.


Данные секции должны быть заданы в следующей последовательности:

a) Секция Элементы управления

b) Секция Векторы элементов управления

c) Секция Ввод действия

d) Секция Ввод объекта

e) Секция Константы (может полностью отсутствовать)

f) Секция Наборы данных

g) Секция Индексы для векторов и циклов

h) Секция Тексты справки

i) Секция Тексты ошибок

j) Секция Преобразование ошибок

k) Секция Достоверизация

l) Секция Блоки статусов элементов управления

m) Секция Макрос алгоритма

n) Секция Фазы диалога


Существует так называемый механизм Include, который позволяет обрабатывать отдельные, включенные друг в друга Includes вплоть до самого нижнего уровня. Алгоритм Include имеет следующий синтаксис:

INCLUDE < Строка >

Он означает следующее:

Если строка является действительным именем файла, то этот файл подключается, если для чтения его необходимо открыть и он еще не подключен. Если строка равна (т.е эквивалентна) нулю "0", то присоединяется тот файл, имя которого было указано в качестве первого параметра строки параметров при запуске диалога или его планировании, если для чтения его необходимо открыть и он еще не подключен.


1.11.1  Элементы управления

В этой секции выполняется спецификация всех элементов управления, которые требуются для управления диалогом. Они должны быть в наличии в используемом для диалога шаблоне окна. Спецификация начинается с ключевого слова

BEDELM{

и заканчивается ключевым словом

}BEDELM

Для каждого элемента управления объявляется тип, имя и окно:

< Тип > < Элемент управления > < Окно > < Имя > < Статус блокировки >

< Тип >: Предопределенное название типа графического элемента управления. Заданы следующие элементы управления:

CONTAINER      : Границы окна CONTAINERVEK   : Вектор границ окна SYMBOL         : Элемент управления с предопределенным символом (например, кнопка иконки, кнопка закрытия, кнопка изменения размера ...) SYMBOLVEK      : Вектор элементов управления символами BALKEN         : Полосы прокрутки (например, полосы вертикальной и горизонтальной прокрутки ...) BALKENVEK      : Вектор полос прокрутки SLIDER         : Слайдер SLIDERVEK      : Вектор слайдеров TEXTOUT        : Элемент управления для вывода текста(например, кнопки с текстом, метки, строки указаний ...) TEXTOUTVEK     : Вектор элементов управления для вывода текста PICTURE        : Контейнер для информации об изображении PICTUREVEK     : Вектор контейнеров для информации об изображении TEXTOUTTIMED   : Элемент управления для вывода текстовой информации и информации о времени с автоматическим обновлением времени TEXTOUTTIMEDVEK: Вектор TEXTOUTTIMED TEXTOUTIN      : Элемент управления для ввода/вывода текста TEXTOUTINVEK   : Вектор TEXTOUTIN KUCONT         : Контейнер графиков для вывода и управления отображением графиков KUCONTVEK      : Вектор контейнеров графиков TEXTOUTFL      : Элемент управления для вывода текста с маркировками строк TEXTOUTFLVEK   : Вектор TEXTOUTFL DRAWOBJ        : Область/поле рисования для графического интерфейса DRAWVEK        : Вектор DRAWOBJ TEXTEDIT       : Элемент управления для многократного ввода/вывода текста TEXTEDITVEK    : Вектор TEXTEDIT


Вся входные данные, относящиеся к типам элементов управления DRAWOBJ или DRAWVEK, всегда передаются напрямую пользователю и не могут быть обработаны в DIAT!!!

< Элемент управления >: Идентификатор элемента управления, находящегося в файле шаблона, для используемого окна. Он может состоять макс. из 16 символов. Тип элемента управления должен соответствовать(т.е. совпадать) типу в файле шаблона. Если идентификатор содержит специальный (служебный) знак, то он должен быть установлен между '"'.

< Окно >: Название окна, соответствующее импользуемому типу шаблона, в котором есть данный элемент управления. Имя может состоять макс. из 16 символов.

< Имя >: Название элемента управления, используемое в DIAT, может состоять макс. из 16 символов и должно быть однозначным среди всех имен в этой секции.

Пример: BEDELM{ TEXTOUT   Метка        DMS_окно  DMS_метка CONTAINER Границы окна DMS_окно  DMS_границы_окна TEXTOUT   Имя          Вспом.окно  Имя ... }BEDELM

< Статус блокировки >: Статус блокировки указывает, при каком статусе элемента управления входные данные не будут переданы в процесс управления диалогом (см. файл шаблона PASSIV STATE).

Статус элемента управления == Статус блокировки: передача входной информации отсутствует Статус элемента управления != Статус блокировки: осуществляется передача входной информации

Путем ввода символов в формате ASCII обработка статуса блокировки для соответствующего элемента отключается.

1.11.2  Секция Векторы элементов управления

В этой секции элементы управления объединяются в векторы, благодаря чему становится возможным индексированный доступ к отдельным элементам управления. Задания для индексированных элементов управления вектора действуют также, как и такие же задания для выбранного напрямую элемента управления. Задания, которые направлены субобъектам отдельных элементов управления, не распространяются на вектор элементов управления.

Секция начинается с ключевого слова

VEKBED{

и заканчивается ключевым словом

}VEKBED


Каждый элемент вектора объявляется следующим образом:

< Имя вектора > < Имя > < Субобъект > < Маска >

< Имя вектора >: Используемое в DIAT имя вектора элементов управления; состоит макс. из 16 символов и является однозначным среди всех векторов в том отношении, что все строки, которые несут то же самое имя вектора, соподчиняют последующий элемент управления именно этому вектору в качестве элемента.

Последовательность появления одинаковых имен векторов определяет порядок соподчинения элементов управления позициям индексов вектора.

Соподчинения элементов управления какому-либо вектору не должны выполняться в в одном связанном блоке, а могут быть смешаны с соподчинениями к другим векторам.

< Имя >: Имя элемента управления, который соподчинен текущей позиции индекса вектора. Имя должно быть задано в секции "Элементы управления". Элемент управления может быть соподчинен определенное ограниченное количество раз одному или нескольким векторам (см. Субобъект).

< Субобъект >: Номер субобъекта соподчиненного элемента управления. Для одного элемента управления допустимо макс. 100 субобъектов. Если в элементе управления отсутствует субобъект или если обращение выполняется ко всему элементу управления, имеющему субобъекты, то в таком случае нужно указать 'A'. Элемент управления с одним и тем же субобъектом нельзя соподчинить нескольким векторам одновременно. Элемент управления, который соподчинен вектору с помощью 'A'(для обращения ко всему элементу управления сразу) может быть соподчинен только этому вектору с различными реальными субобъектами. Различные субобъекты элемента управления могут быть соподчинены различным векторам, если они не соподчинены другому вектору с помощью 'A'.

< Маска >: Она управляет начальным поведением вектора элементов управления. Могут выть указаны:
1.) 0 (нуль)
2.) последовательность I C, где каждый символ встречается в последовательности макс. 1 раз.

Пояснение к 1.)  Введенный объект элемента управления вектора, указанного в маске соответствующим образом, не отображается в векторе, а соподчиняется лишь элементу управления, причем ему передается индекс элемента управления в векторе (TELE.vekobj = индекс). Если для элемента управления отсутствует запись в секции "Ввод объекта", то входные данные игнорируются.

к 2.)  Введенный объект (C,I) привязывается к вектору, если этого категорически требует соответствующая маска (C I). Индекс вектора передается (TELE.vekobj = индекс). Если для вектора отсутствует подходящая запись в секции "Ввод объекта", то входные данные игнорируются. Если введенные данные не подходят для маски, то действуют согласно п.1.)

Элементы управления, которые не соподчинены ни одному вектору, при вводе данных передают обратно параметр TELE.vekobj = -1.

1.11.3  Секция Ввод действия

В данной секции приводятся все действия ЦДД, которые могут поступать в DIAT в процессе управления диалогом и должны быть там обработаны вне зависимости от фазы или шага диалога. Секция начинается с ключевого слова

AKTINP{

и заканчивается ключевым словом

}AKTINP

Каждый ввод действия объявляется следующим образом:

< Действие > < Случай >

< Действие >: Сокращение(аббревиатура) действия, макс. 4 символа, которое должно быть представлено в списке всех действий ЦДД (см. Спецификация ЦДД ), когда ЦДД должен запустить какой-либо из возможных случаев действий. Для связи внешнего пользователя с его диалогом или с несколькими диалогами в DIAT действие может быть произвольно придумано, правда его имя не должно совпадать с имеющимися действиями ЦДД. Оно должно быть однозначным. Действие может быть также действием параметров.


< Случай >: Произвольно выбираемый идентификатор, который связывает полученные данные с процессом, заданным в секции "Фазы диалога". На основе определенного(т.е. идентифицированного) случая принимается решение о дальнейших действиях диалога. Идентификатор может состоять макс. из 16 символов и должен быть однозначным.

Пример: AKTINP{ DIAB Прервать CLWI close RSWI resize MVWI move_win OPSW open_window ... TEST связь JOJO письмо NANU сообщение .... }AKTINP

Если действия ЦДД, которые возможно могли бы встретиться во время работы диалога, не определены в качестве входных действий, то по умолчанию автоматически выполняется соответствующая внутренняя функция. Таким образом, параметры ЦДД всегда будут актуальными, однако право вето не может быть наложено на выполняемые действия.

1.11.4  Секция Ввод объекта

В этой секции приводятся все объекты, которые могут поступать в DIAT в процессе управления диалогом и должны быть там обработаны вне зависимости от фазы или шага диалога. Секция начинается с ключевого слова

OBJINP{

и заканчивается ключевым словом

}OBJINP


Каждый ввод объекта объявляется следующим образом:

< Объект > < Статус > < Случай >

< Объект >: Имя элемента управления, представленного в секции "Элементы управления" ( Параметр < Имя > ) или имя вектора, представленного в секции "Векторы элементов управления" ( Параметр < Имя вектора > ).

< Статус >: Статус относится к статусу ввода объекта, который должен быть передан в диалог. Заданы следующие статусы:

C  -> Выбор курсора I  -> Содержимое объекта F  -> Функциональные и прочие кнопки

Статус вместе с объектом должны быть однозначными. Если статуса=C не существует, то выбор курсора при необходимости передается с помощью статуса=F.

< Случай >: Произвольно выбираемый идентификатор, который связывает полученные данные с процессом, заданным в секции "Фазы диалога". На основе определенного(т.е. идентифицированного) случая принимается решение о дальнейших действиях диалога. Идентификатор может состоять макс. из 16 символов и должен быть однозначным.

Пример: OBJINP{ DMS_label  I Ввод метки DMS_label  C Выбор метки DMS_Rahmen C Субдиалог_akt Name       I Ввод имени ... }OBJINP

При наличии такого случая в объявленном (внутри) наборе данных TELE подготавливаются следующие данные:

TELE.status   = внутренняя метка случая            (a) TELE.hilf     = внутренний индекс окна             (b) TELE.subobj   = субобъект                          (c) TELE.vekobj   = индекс вектора                     (d) TELE.bedelm   = номер элемента управления          (e) TELE.par1     = Параметр 1 элемента управления     (f) ... TELE.par5     = Параметр 1 элемента управления     (f) TELE.wert     = Строка параметров элемента управл. (g)

к (a) : Передается метка текущего случая. (C I F)

к (b) : Начинающаяся с 0 относительная нумерация всех заданных в диалоге окон определяет внутренний индекс для каждого окна. Передается номер того окна, который вызвал ввод данных.

к (c) : Если элемент управления, генерирующий ввод данных, содержит субобъект, который является собственным автором ввода, то передается такой субобъект, в противном случае -1.

к (d) : Если элемент управления, генерирующий ввод данных, соподчинен вектору, то передается индекс вектора, в противном случае -1.

к (e) : Начинающаяся с 0 относительная нумерация всех заданных в диалоге элементов управления. Передается номер текущего элемента управления.

к (f) : Элемент управления при вводе данных передает особые (специфические) параметры в качестве строки (String). Внутри этой строки информация подразделена символами пробела. В зависимости от количества блоков информации в TELE.par1 до TELE.par5 находятся подстроки или символы пробела. Длина подстроки составляет макс. 32 символа. Если под элементом управления понимается функциональная или какая-либо другая кнопка (статус F ввода объекта ), то в TELE.par1 передается код кнопки. Телеграмма G_INFOOBJSIZE представлена в коде кнопки как "-1" и имеет 6 параметров: vir_width/height (по отношению к монитору) new_width/height (в пикселях) old_width/height (в пикселях)

к (g) : TELE.wert содержит оригинальную строку параметров ввода элемента управления. Макс. длина строки составляет 100 символов.

1.11.5	Секция Константы

В этой секции могут быть объявлены константы. Константы могут использоваться во всех алгоритмах, в которых допустим тип операнда < String >  (см. Алгоритмы наборов данных). Секция начинается с ключевого слова

KONSTANT{

и заканчивается ключевым словом

}KONSTANT

Каждая константа может быть объявлена следующим образом:

< Имя константы > < String >

< Имя константы >: Произвольно выбираемый однозначный идентификатор константы, макс. 16 символов.

< String >: "< ASCII_символы >"

Если идентификатор используется многократно, то действительным является лишь его первое задание. Благодаря этому можно поместить константы настроек во внешний include-файл, а вне его определить значения по умолчанию, если они не заданы в include-файле.

1.11.6  Секция Наборы данных

В данной секции представлены все буферы наборов данных, которые требуются, когда DIAT управляет диалогом. Для наборов данных задается лишь структура, а не их содержимое. Секция начинается с ключевого слова

DATSAT{

и заканчивается ключевым словом

}DATSAT

Каждый набор данных объявляется следующим образом:

< Имя набора данных > < Формат данных > < Список элементов данных >

< Имя набора данных >: < Имя > или < Имя > [ < Размер вектора > ]

< Имя >: Произвольно выбираемый однозначный идентификатор набора данных, макс. 16 символов.

< Размер вектора >: Целое число в промежутке от 0 до 1024 включительно. При значении 0 вектор не создан, в противном случае создается вектор из структурированного таким же образом набора данных, область индексов которого определяется из размера вектора.

< Формат данных >: Строка формата согласно синтаксису языка С для отформатированного ввода/вывода. Допустимыми являются:

%d    -> Typ long %x    -> Typ long hexadezimal %X    -> Typ long hexadezimal (Вывод прописными(большими) буквами) %f    -> Typ double %e    -> Typ double %E    -> Typ double (Вывод с прописной E) %g    -> Typ double %G    -> Typ double (Вывод при необходимости с прописной E) %<n>s -> Typ String

Допустимыми являются также общепринятые для языка C расширения формата (такие, как, например, %-32s и т.д.). Максимальный размер элемента данных составляет 999 байт.


< Список элементов данных >: < Имя элемента данных > ...

< Имя элемента данных >: < Имя > или < Имя > [ < Размер вектора > ]


Список имен элементов данных, разделенных символами пробела и соподчиненных элементам набора данных, заданным в строке формата.

Имя содержит макс. 16 символов и должно быть однозначным в наборе данных. Для элементов данных, заданных в виде вектора, соответствующий элемент формата должен быть указан лишь один раз.

Пример: DATSAT{ window    "%s" name ergebnis  "%d %d %x %20s" prio klasse maske klartext vektor[5] "%f %f %16s" minwert maxwert name wert      "%f %f %16s" start stop name[3] kurve[3]  "%f %f" x[20] y[20] ... }DATSAT

Используя следующий синтаксис, можно обратиться (получить доступ) к набору данных:

< Имя набора данных >

< Имя набора данных >.< Имя элемента данных >

При этом < Имя набора данных > может содержать индексацию, если это предусмотрено при объявлении.

Для каждого объявленного таким образом набора данных создается элемент статуса дополнительно к указанным элементам данных. Кроме того, устанавливается флаг изменения, который несет маркировку изменения набора данных.

Для каждого объявленного элемента данных дополнительно создается элемент статуса и устанавливается флаг изменения. Элемент статуса несет(обозначает) достоверность элемента, флаг изменения маркирует элемент, если его содержимое было изменено, пока флаг не будет сброшен в алгоритме.

К статусу набора данных можно получить доступ с помощью::

< Имя набора данных >.STA

К флагу набора данных можно получить доступ с помощью:

< Имя набора данных >.FLAG

К статусу элемента данных можно получить доступ с помощью:

< Имя набора данных >.< Имя элемента данных >.STA

К флагу изменения элемента данных можно получить доступ с помощью:

< Имя набора данных >.< Имя элемента данных >.FLAG

1.11.7  Секция Индексы для векторов и циклов

В данной секции объявляются все индексы, требуемые в диалоге для индексации вектора и счетчика циклов. Секция начинается с ключевого слова

INDEX{

и заканчивается ключевым словом

}INDEX

Каждый индекс объявляется следующим образом:

< Имя индекса >

< Имя индекса >: Произвольно выбираемый однозначный идентификатор индекса, макс. 16 символов, должен быть однозначным среди всех наборов данных. Внутренний формат данных индекса - целочисленный (short).

К индексу можно получить доступ с помощью:

< Имя индекса >

К векторам наборов или элементов данных можно получить индексированный доступ только с помощью индексов или констант.

Пример:

ergebnis.klasse = vektor[0].minwert ind = 2 vektor[ind].name = "BRINGFRIEDE" ergebnis.prio = vektor[ind].STA ergebnis.maske = vektor[ind].minwert.FLAG kurve[ind].x[2] = kurve[2].y[ind]


1.11.8  Секция Тексты справки

В данной секции представлены все имеющиеся в диалоге тексты справки. Секция начинается с ключевого слова

HELP{

и заканчивается ключевым словом

}HELP

Для каждого текста справки вносится запись следующего синтаксиса:

< Номер > < Строка текста справки >

< Номер >: Однозначный целочисленный номер текста справки. Этот номер может встречаться в секции неоднократно. Строки с одинаковыми номерами относятся к одному и тому же тексту справки и должны следовать непосредственно друг за другом. Последовательность строк в тексте справки соответствует последовательности записей с одним и тем же номером в файле управления.

Под однозначностью номера понимается тогда следующее: Одинаковые номера относятся к одному и тому же тексту справки, разные номер никогда не могут относиться к одному и тому же файлу.

< Строка текста справки >: Строка текста справки содержит макс. 80 символов и должна быть заключена в "".

К одному тексту справки может относиться макс. 32 строки текста.


1.11.9  Секция Тексты ошибок

В данной секции приведены все имеющиеся в диалоге тексты ошибок. Секция начинается с ключевого слова

FEHLER{

и заканчивается ключевым словом

}FEHLER

Для каждой ошибки вносится запись следующего синтаксиса:

< Номер > < Текст ошибки >

< Номер >: Однозначный целочисленный номер текста ошибки.

< Текст ошибки >: Текст описания ошибки, состоящий макс. из 80 символов, заключенный в "" .

1.11.10  Секция Преобразование ошибок

В данной секции представлены все имеющиеся в диалоге преобразования между статусом и текстом ошибки. Секция начинается с ключевого слова

KONFEH{

и заканчивается ключевым словом

}KONFEH

Для каждого преобразования вносится запись следующего синтаксиса:

< Konvert > ( < Список статусов > | < Список номеров ошибок > )

< Konvert >: Однозначное имя преобразования статуса ошибки в номер ошибки, который должен быть в секции "Тексты ошибок". Имя может состоять макс. из 16 символов.

< Список статусов >: Макс. 16 номеров статуса, разделенных между собой символами пробела.

< Список номеров ошибок >: Последовательность номеров ошибок, разделенных символами пробела, такого же количества, что и список статусов.


N-ая запись в списке статусов преобразуется в n-ую запись в списке номеров ошибок и ссылается при этом на текст ошибки в соответствующей секции.

1.11.11  Секция Достоверизация

В данной секции определяются различные методы достоверизации наборов и элементов данных. Секция начинается с ключевого слова

PLAUSI{

и завершается ключевым словом

}PLAUSI

Для каждого объекта, достоверность которого нужно проверить (элемент данных, набор данных), выполняется одна или несколько записей.

Для внешних по отношению к пользователю, формирующему задание, данных, которые требуется проверить на достоверность, это выполняется с использованием следующего синтаксиса:

EXTERN < Имя набора данных > < Время ожидания >

или

EXTERN < Имя набора данных >.< Имя элемента данных > < Время ожидания >

В качестве имени набора данных допускаются лишь наборы данных и элементы вектора наборов данных с постоянным индексом.

В качестве имени элемента данных допускаются лишь элементы данных и элементы вектора элементов данных с постоянным индексом.

< Время ожидания >: Время в секундах, в течение которого ожидается получение результата достоверизации. Превышение этого времени в данном случае означает прерывание диалога.

При внешней достоверизации соответствующая телеграмма задания отправляется внешнему пользователю. Для достоверизации элемента данных имеет место следующий синтаксис:

PEAN < Имя диалога > < Имя набора данных >.< Имя элемента данных > | < Значение элемента данных >

< Значение элемента данных >: Текущее содержимое элемента данных в отформатированном виде согласно тому, как он был объявлен.

Для достоверизации набора данных имеет место следующий синтаксис телеграммы:

PSAN < Имя диалога > < Имя набора данных >

В течение < Времени ожидания > ожидается получение телеграммы результата. При истечении времени ожидания диалог прерывается. Телеграмма результата должна быть вида

- задание на достоверизацию набора данных

или

- задание на достоверизацию элемента данных.



Для данных, которые необходимо проверить на достоверность с помощью DIAT, используется следующий синтаксис ( внутренняя проверка достоверности может быть выполнена лишь элементов данных):

INTERN < Имя набора данных >.< Имя элемента данных > < Алгоритм проверки достоверности >


В качестве имени набора данных допускаются лишь наборы данных и элементы вектора наборов данных с постоянным индексом.

В качестве имени элемента данных допускаются лишь элементы данных и элементы вектора элементов данных с постоянным индексом.


< Алгоритм проверки достоверности >: < Процедура достоверизации > ( < Список объектов > ) < Сдвиг >

< Процедура достоверизации >: Ключевое слово из числа всех процедур достоверизации. Имеются следующие процедуры:

STRNIL Проверка наличия строки с хотя бы одним символом, не равным пробелу, или в случае ошибки, является ли строка пустой или содержит пробелы.

1й параметр: строка, проверку которой необходимо выполнить

Значения статуса означают следующие варианты ошибок:
1 -> Строка является пустой(нулевой)
2 -> Строка содержит пробелы

STRLNG Проверка минимальной и максимальной длины строки.

1й параметр: строка, проверку которой необходимо выполнить
2й параметр: минимальная длина
3й параметр: максимальная длина

Значения статуса означают следующие варианты ошибок:
1 -> строка слишком короткая
2 -> строка слишком длинная

STREQU Проверка идентичности строк.
1й параметр: строка, проверку которой необходимо выполнить
2й параметр: сравниваемая строка

Значения статуса означают следующие варианты ошибок:
1 -> 1й параметр короче
2 -> 1й параметр длиннее
3 -> оба параметра одной длины, но не идентичны

STREQI Проверка идентичности строк (case-insensitiv, т.е. случай нечувствительности к регистру).
1й параметр: строка, проверку которой необходимо выполнить
2й параметр: сравниваемая строка

Значения статуса означают следующие варианты ошибок:
1 -> 1й параметр короче
2 -> 1й параметр длиннее
3 -> оба параметра одной длины, но не идентичны

STRNEQ Проверка неравенства строк.
1й параметр: строка, проверку которой необходимо выполнить
2й параметр: сравниваемая строка

Значения статуса означают следующие варианты ошибок:
1 -> оба параметра идентичны

STRVOR Проверка на соответствие алфавитному порядку.
1й параметр: строка, проверку которой необходимо выполнить
2й параметр: сравниваемая строка

Значения статуса означают следующие варианты ошибок:
1 -> 1й параметр не находится перед 2-м параметров в алфавитном порядке

STRNAC Проверка  на соответствие алфавитному порядку.
1й параметр: строка, проверку которой необходимо выполнить
2й параметр: сравниваемая строка

Значения статуса означают следующие варианты ошибок:
1 -> 1й параметр не находится после 2-го параметра в алфавитном порядке

STRENT Проверка, содержит ли сравниваемая строка исходную строку.
1й параметр: строка, проверку которой необходимо выполнить
2й параметр: сравниваемая строка

Значения статуса означают следующие варианты ошибок:
1 -> 1й параметр не содержит 2й параметр

STRNAM Проверка, является ли строка именем, т.е. первый символ должен быть буквой а все остальные символы могут быть буквами, цифрами или содержать _.
1й параметр: строка, проверку которой необходимо выполнить

Значения статуса означают следующие варианты ошибок:
1 -> Параметр не является именем

STRMAT Сравнивает 2 строки со следующими специальными (служебными) знаками (см.awl_srt.h): ? : любой символ * : любое количество любых символов [ : начало выбора символов ] : конец выбора символов { : начало альтернативы , : следующая алтернатива } : конец альтернативы \ : следующий символ без особого значения внутри выбранных символов означает:
^ : в качестве первого символа -> отрицание (инвертирование) ] : возможно только в качестве первого символа (при необходимости после ^)
- : возможно только в качестве первого символа x-y: область символов от x до y <flt> ::= {<chr>|<wld>|<aus>|<alt>|<esc>} <chr> ::= [^][{,}?*\] т.е. все символы кроме '][{,}?*\' <wld> ::= '?'|'*' <esc> ::= '\'<any> <alt> ::= '{'<flt>{','<flt>}'}' <aus> ::= '['<any-'-^'>{<any-'-]'>|<rng>}['-']']' |'[^'<any-'-'>{<any-'-]'>|<rng>}['-']']' <rng> ::= <any-'-]'>'-'<any-'-]'>

1й параметр: строка, проверку которой необходимо выполнить
2й параметр: сравниваемая строка

Значения статуса означают следующие варианты ошибок:
0   -> отсутствуют совпадения !=0 -> совпадение

DATIM Проверка, является ли параметр строкой с датой или временем. Формат является относительно произвольным, могут использоваться сокращения, как описано для DATUM и ZEIT: "5."          -> 05.05.04 12:00:00 "5. 6"        -> 05.05.04 06:00:00 "6: 5"        -> 05.05.04 06:28:00 "5. 6:"       -> 05.05.04 06:28:00 "5. 6:3"      -> 05.05.04 06:03:00 "5.2 6::"     -> 05.02.04 06:28:37 "5.2.3 6::3"  -> 05.02.03 06:28:03

Для значения статуса возможен лишь 1 вариант ошибки:
1 -> не достоверна

Проверка достоверности строки выполняется путем ее пробного преобразования с помощью команды str2sec. Но она, конечно, имеет недостаток: иногда принимаются также и недостоверные значения (или они игнорируются, а сообщение об ошибке не поступает). Если такое значение вдруг попадется, сообщите пожалуйста об этом :)

DATUM Проверка, является ли параметр датой в формате ДД.ММ.ГГ или ДД.ММ.ГГГГ. Данные могут частично выпадать из строки с датой справа налево, включая '.' . Для отсутствующих данных, соответственно, устанавливается текущее значение.
1й параметр: строка, проверку которой необходимо выполнить

Значения статуса означают следующие варианты ошибок:
1 -> параметр не соответствует двум вышеуказанным форматам
2 -> недопустимое значение года (0 - 99 или 1970 - 2069)
3 -> недопустимое значение месяца (1 - 12)
4 -> недопустимое значение дня согласно календарю

ZEIT Проверка, является ли параметр временем в формате ЧЧ:ММ:СС. Данные могут частично выпадать из строки со временем справа налево, включая '.' . Для отсутствующих данных устанавливается значение 0. Указание часа является(ЧЧ) является обязательным требованием.
1й параметр: строка, проверку которой необходимо выполнить

Значения статуса означают следующие варианты ошибок:
1 -> параметр не соответствует вышеуказанному формату
2 -> недопустимое значение часа (0 - 23)
3 -> недопустимое значение минуты (0 - 59)
4 -> недопустимое значение секунды (0 - 59)

FLTZAHL Проверка, является ли параметр числом с плавающей запятой (double).
1й параметр: строка, проверку которой необходимо выполнить

Значения статуса означают следующие варианты ошибок:
1 -> параметр не является числом с плавающей запятой

FLTBER Проверка, принадлежит ли параметр области значений с плавающей запятой, включая границы области.
1й параметр: строка, проверку которой необходимо выполнить
2й параметр: нижняя граница области
3й параметр: верхняя граница области

Значения статуса означают следующие варианты ошибок:
1 -> параметр находится за границами области

INTZAHL Проверка, является ли параметр целым числом (long).
1й параметр: строка, проверку которой необходимо выполнить

Значения статуса означают следующие варианты ошибок:
1 -> параметр не является целым числом

INTBER Проверка, принадлежит ли параметр области целых значений, включая границы области.
1й параметр: строка, проверку которой необходимо выполнить
2й параметр: нижняя граница области
3й параметр: верхняя граница области

Значения статуса означают следующие варианты ошибок:
1 -> параметр находится за границами области

HEXZAHL Проверка, является ли параметр шестнадцатеричным числом (long).
1й параметр: строка, проверку которой необходимо выполнить

Значения статуса означают следующие варианты ошибок:
1 -> параметр не является шестнадцатеричным числом

BINZAHL Проверка, является ли параметр бинарным числом (long).
1й параметр: строка, проверку которой необходимо выполнить

Значения статуса означают следующие варианты ошибок:
1 -> параметр не является бинарным числом

Другие проверки достоверности целых чисел и чисел с плавающей запятой должны указываться по требованию.

< Список объектов >: < Объект > < Объект > ...

< Объект >: < Имя набора данных >.< Имя элемента данных > или < Строка >

Список объектов представляет собой удобный для процесса достоверизации перечень элементов данных или строк, предназначенных для проверки достоверности, а также необходимых базовых элементов, разделенных знаками пробела.

Первый элемент данных или первая строка в списке проверяется на достоверность, остальные элементы данных или строки являются базовыми элементами. Строка может содержать макс. 30 символов.

< Сдвиг >: Целое число, на которое сдвигаются значения статусов при достоверизации, пока они не будут равны 0. Это приводит к сплошной (без пропусков) нумерации всех вариантов ошибок элемента, проверка достоверности которого выполнялась неоднократно.

Результаты проверки достоверности сохраняются в соответствующем статусе первого элемента данных из соответствующего списка.

Если проверка достоверности элемента данных выполняется многократно, то последовательность проверок завершается при первом результате недостоверности. Если элемент данных набора данных является недостоверным, то набор данных также будет недостоверным и будет нести метку достоверности первого недостоверного элемента в порядке всех своих элементов. Набор данных достоверный, если все его элементы достоверны.


1.11.12  Секция Блоки статусов элементов управления

В данной секции элементы управления, статусы графического изображения которых должны быть установлены в определенных позициях в зависимости от номера версии, объединяются в блоки. Вследствие этого можно достичь предустановленной позиции статуса в объединенных элементах управления путем указания номера версии, а не загружать каждый отдельный элемент управления с соответствующим графическими алгоритмами.

Задания, направленные элементу блока статусов элементов управления, действуют также, как и соответствующее задание графических свойств непосредственно для самого элемента управления.

Секция начинается с ключевого слова

STABED{

и заканчивается ключевым словом

}STABED  .

Каждый элемент блока статусов элементов управления объявляется следующим образом:

< Имя блока > < Имя > < Субобъект > ( < Список статусов > )

< Имя блока >: Используемое в DIAT имя блока статусов элементов управления; состоит макс. из
16 символов и является однозначным среди всех имен блоков в том отношении, что все строки, которые несут то же самое имя блока, соподчиняют последующий элемент управления именно этому блоку в качестве элемента.

Последовательность появления одинаковых имен блоков определяет порядок графического обновления статусов элементов управления, входящих в блок статусов.

Соподчинения элементов управления какому-либо блоку не должны выполняться в взаимосвязанной последовательности, а могут быть смешаны с соподчинениями другим блокам.

< Имя >: Имя элемента управления или вектора элементов управления, который соподчинен блоку статусов элементов управления. Имя должно быть задано в секции "Элементы управления" или "Векторы элементов управления". Элемент управления может быть соподчинен определенное, ограниченное количество раз одному или нескольким блокам.

< Субобъект >: Номер субобъекта соподчиненного элемента управления. Если в элементе управления отсутствует субобъект или если обращение выполняется ко всему элементу управления, имеющему субобъекты, то в таком случае нужно указать 'A'. Элемент управления с одним и тем же субобъектом нельзя соподчинить одному и тому же блоку несколько раз одновременно. Элемент управления, который соподчинен блоку с помощью 'A'(для обращения ко всему элементу управления сразу) не может быть соподчинен этому же блоку еще раз с каким-либо другим субобъектом.

< Список статусов >: Регулирует выбор статуса элемента управления в зависимости от номера версии. Значения статусов могут быть предустановлены макс. для 10 версий, которые должны находиться в области статусов для соответствующего элемента управления [ от 0 до 4 ]. Номера версий начинаются с 0. Таким образом, первое значение из списка статусов соподчиняется версии 0 и т.д.

Пример :

STABED{ awt kgr    A (2 2) awt kur    A (1 2) awt strcur A (1 2) }STABED

3 элемента управления kgr, kur и strcur объединены в один блок. Значения статусов заданы для 2х версий: Версия 0 : kgr    -> 2     Версия 1 : kgr    -> 2 kur    -> 1                kur    -> 2 strcur -> 1                strcur -> 2

1.11.13  Секция Макросы алгоритмов

В данной секции повторяющиеся последовательности алгоритмов объединяются и им дается имя. Секция начинается с помощью ключевого слова

MAKRO{

и заканчивается ключевым словом

}MAKRO

Секция имеет следующую внутреннюю структуру:

< Имя макроса >{ < Алгоритм > < Алгоритм > < Алгоритм > < Алгоритм > ... }< Имя макроса >

< Имя макроса >: Однозначный, состоящий макс. из 16 символов идентификатор макроса, который не должен совпадать с идентификатором набора данных или именем индекса.

< Алгоритм >: Все алгоритмы, описанные в пунктах "Запуск шага_фрагмент" и "Диалог_фрагмент". Макросы могут быть включены один в другой. Глубина таких вложений макросов ограничена (в наст.время 10).


1.11.14  Секция Фазы диалога

В данной секции задаются различные фазы диалога. Фаза начинается ключевым словом

PHASE{

и заканчивается ключевым словом

}PHASE

Фаза имеет следующую внутреннюю структуру:

NAME < Имя фазы > SCHRITT < Имя шага > < Глобальный блок случаев > < Блок шага > < Блок шага > < Блок шага > ... < Блок управления шагами >

1.11.14.1  Задание имен

Каждая фаза имеет однозначное имя, макс. 16 символов, которое соподчиняется фазе с помощью следующей записи:

NAME < Имя фазы >

< Имя фазы >: Однозначный идентификатор фазы, состоит макс. 16 символов.

1.11.14.2  Начальный шаг фазы

При запуске фазы диалога он начинается с предопределенного шага, который задается следующим образом:

SCHRITT < Имя шага >

< Имя шага >: Однозначный в рамках фазы диалога и состоящий макс. из 16 символов идентификатор имеющегося блока шага.



1.11.14.3  Глобальный блок случаев

Он начинается с ключевого слова

FALL{{

и заканчивается ключевым словом

}}FALL

Глобальный блок статусов может отсутствовать, если в соответствующих фрагментах диалога всех шагов фазы задана соответствующая обработка случая. Если есть случаи, которые должны быть обработаны аналогичным образом вне зависимости от шага фазы, на котором они находятся, то обработка случая может быть указана в глобальном блоке случаев. Если заданная в шаге диалога обработка случая существует под тем же именем, то она обладает приоритетом по сравнению с глобальной.

Для каждого глобального случая, предназначенного для стандартной обработки, с помощью следующего синтаксиса определяется обработка:

< Случай >{ < Алгоритм > < Алгоритм > < Алгоритм > ... < Внутренняя функция > < Внутренняя функция > ... }< Случай >

< Случай >: Заданный в секции "Ввод действия" или "Ввод объекта" идентификатор случая.

< Алгоритм >: Один из заданных в главе "Запуск шага_фрагмент" алгоритмов, если они являются целесообразными и возможными в "Диалог_фрагмент".


< Внутренняя функция >: Идентификатор внутренней функции, известной DIATу при программировании, которая должна быть выполнена на основе случая. В настоящее время заданы следующие идентификаторы:

CLWI  прерывание диалога, закрытия окна DIAB  прерывание диалога, закрытия окна OPSW  открытие стандартного окна OPWT  открытие окна определенного типа RSWI  изменение размеров окна MVWI  перемещение окна VGWI  окно на передний план HGWI  окно на задний план ...

Если существуют соответствующие введенные действия, то эти внутренние функции должны выполняться вместе с ECHO-алгоритмом, если на действие не должно быть наложено право вето.

ECHO  Передача телеграммы испольнительному устройству ЦДД При наличии записи ключевого слова ECHO входная телеграмма передается обратно ЦДД. Если запись отсутствует, то обработка телеграммы в DIATе завершается.

1.11.14.4  Блок шага

Фазы диалога подразделены на шаги. У каждого шага есть время ожидания(выдержка) входных данных в отношении всех возможных случаев входных данных. Кроме того, каждый шаг обладает своим собственным графическим представлением. Внутри фазы диалога шаг представлен блоком шага. Блок шага начинается ключевым словом

SCHRITT{{

и заканчивается ключевым словом

}}SCHRITT

Он имеет следующую внутреннюю структуру:

NAME < Имя шага > < Запуск шага_фрагмент > < Повтор шага_фрагмент > < Прерывание шага_фрагмент > < Конец шага_фрагмент > < Диалог_фрагмент >


"Запуск шага_фрагмент" содержит все алгоритмы, которые должны быть выполнены для запуска шага.

"Повтор шага_фрагмент" содержит все алгоритмы, которые должны повторяться после ошибок диалога.

"Прерывание шага_фрагмент" содержит все алгоритмы, которые должны быть выполнены в случае безоговорочного прерывания шага.

"Конец шага_фрагмент" содержит все алгоритмы, которые должны быть выполнены однократно при завершении шага.

"Диалог_фрагмент" описывает поведение шага диалога.

Любой из этих фрагментов может существовать или отсутствовать вне зависимости от других. Если же они существуют, то должна соблюдаться вышеуказанная последовательность.

1.11.14.4.1    Имя шага

У каждого шага в фазе диалога есть однозначный идентификатор, состоящий макс. из 16 символов. Он задается с помощью следующей записи:

NAME < Имя шага >

< Имя шага >: Однозначный в рамках фазы диалога и состоящий макс. из 16 символов идентификатор имеющегося блока шага.

При запуске шага предустанавливается выполнение "Запуск шага_фрагмент".

1.11.14.4.2    Запуск шага_фрагмент

Если должен быть выполнен отсутствующий "Запуск шага_фрагмент", то выполняется предустановка выполнения "Диалог_фрагмент". Если такой "Запуск шага_фрагмент" есть в наличии, то выполняется предустановка выполнения "Диалог_фрагмент", а затем выполняются все алгоритмы в "Диалог_фрагмент". Предустановки фрагмента могут быть изменены с помощью алгоритмов.


"Запуск шага_фрагмент" начинается с ключевого слова

ANWS{{{

и заканчивается ключевым словом

}}}ANWS


Между этими ключевыми словами находится перечисление алгоритмов.

Алгоритмы могут быть объединены в блок алгоритмов с определенным именем (локальный макрос) с помощью

< Метка >{

и

}< Метка >.

Это соответствует объявлению макроса. Объявление макроса должно производиться за всеми выполняемыми алгоритмами фрагмента. Обработка алгоритмов за пределами макроса заканчивается перед первым локальным объявлением макроса или в конце фрагмента. Обработка алгоритмов внутри вызываемого макроса заканчивается в месте логического завершения макроса.

< Метка >: Идентификатор, однозначный во всем фрагменте задания, макс. 16 символов. Если идентификатор совпадает с именем макроса, заданным в секции "Макросы алгоритмов", то локальный макрос является более приоритетным. Внутри локальных макросов могут быть вызваны глобальные, но не наоборот.


Предусмотрены следующие алгоритмы:

1.11.14.4.2.1  Алгоритмы наборов данных

В секции "Наборы данных" были структурированно сохранены указанные наборы данных. К этим наборам данных и относятся все алгоритмы наборов данных. При каждом изменении содержимого элемента данных статус параметра и флаг изменения изменяется следующим образом:

Флаг изменения ставится в "изменен", а значение статуса устанавливается в 0.

Заданы следующие типы операндов:

< Тип операнда >: < Набор данных >            или   (DS) < Элемент данных >          или   (DE) < Статус набора данных >    или   (SS) < Статус элемента данных >  или   (ES) < Флаг набора данных >      или   (SF) < Флаг элемента данных >    или   (EF) < Строка >                  или   (ST) < Окно >                    или   (WI) < Индекс >                        (IN)

< Набор данных >: < Знак > < Имя набора данных >

< Элемент данных >: < Знак > < Имя набора данных >.< Имя элемента данных >

< Статус набора данных >: < Знак > < Набор данных >.STA

< Статус элемента данных >: < Знак > < Элемент данных >.STA

< Флаг набора данных >: < Знак > < Набор данных >.FLAG

< Флаг элемента данных >: < Знак > < Элемент данных >.FLAG

< Строка >: "< ASCII_символ >" или < Имя константы >

< Окно >: < Имя окна >      ( глобальный для ЦДД номер окна на мониторе ) или < Имя окна >.x    ( относительная X-координата левого верхнего угла окна ) или < Имя окна >.y    ( относительная Y-координата левого верхнего угла окна ) или < Имя окна >.dx   ( относительная ширина окна ) или < Имя окна >.dy   ( относительная высота окна ) или < Имя окна >.akt  ( высказывание: является ли окно активным )

< Индекс >: < Знак > < Имя индекса >

< Знак >: +      или
-      или ничего



Если для операнда в качестве альтернативы допустимо несколько типов операндов, то это обозначается таким образом, чтобы за операндом в квадратных скобках было представлено сокращение типа операнда, отделенное с помощью символа нижнего подчеркивания _ .

Пример:

< Операнд[IN_WI_DE] >: < Индекс >         или < Окно >           или < Элемент данных >


В наличии имеются следующие алгоритмы:

< Запрос набора данных >: DATEN < Операнд[DS] > < Операнд[IN_ST_DE_DS] > < Операнд[IN_ST_DE] >

DATEN: Сокращение(аббревиатура) команды для 'Запрос данных от внешнего пользователя'.


Параметры в вышеуказанной последовательности означают следующее:

1.) Имя набора данных, который должен быть получен от пользователя, сформировавшего задание. Знак здесь игнорируется.

2.) Опция Строка, которая передается пользователю, сформировавшему задание. Она может быть использована для управления действиями со стороны пользователя, сформировавшего задание. В наборе данных строка генерируется из элементов с поставленным перед ними символом '|'.

3.) Время ожидания Время одидания в секундах, в течение которого подготавливается набор данных. Превышение этого времени в данном случае означает прерывание диалога.

Наборы данных должны быть подготовлены и предоставлены пользователем, сформировавшим задание. Они запрашиваются DIATом с помощью < Запрос набора данных >. DIAT ждет выполнения запроса в течение заданного времени. Если время истекло и это не привело к результатам, DIAT понимает это обстоятельство как задание на прерывание и завершает диалог. Если запрос оказался успешным, то в заданных наборах данных теперь находятся запрошенные данные.

С помощью следующей телеграммы у пользователя, сформировавшего задание, запрашиваются данные:

DAAN < Имя диалога > < Имя набора данных > < Опция >

Ответ должен быть получен в течение времени ожидания с помощью телеграммы < Задание на данные > см 1.8.

Пример с < Имя диалога > = "Dialog" : SELECT "%d %d" anf anz SELECT.anf=5 SELECT.anz=20 DATEN kurve "0"       "10" -> "DAAN Dialog kurve 0" DATEN kurve "1"       "10" -> "DAAN Dialog kurve 1" DATEN kurve "20 plus" "10" -> "DAAN Dialog kurve 20 plus" DATEN kurve SELECT    "10" -> "DAAN Dialog kurve |5|20"


< Экспорт набора данных >: EXPORT < Операнд[DS] > < Операнд[IN_ST_DE] >

EXPORT: Сокращение(аббревиатура) команды для 'Экспорт данных внешнему пользователю'.


Параметры в вышеуказанной последовательности означают следующее:

1.) Имя набора данных, который должен быть отправлен пользователю, сформировавшему задание. Знак здесь игнорируется.


2.) Количество наборов данных, начиная с указанного, которые необходимо экспортировать. Возможны следующие данные: a)  положительное целое число, включая 0 b)  'V' или 'v' c)  'A' или 'a'

zu a) : Экспортируется столько наборов данных, сколько указано с помощью целого числа, однако самое большое количество - сколько наборов данных объявлено в диалоге, начиная с первого набора данных. zu b) : Если начальный набор данных не является элементом вектора, то экспортируется только он. Если начальный набор данных является элементом вектора, то экспортируются только относящиеся к тому же самому вектору наборы данных, начиная с этого. zu c) : Экспортируются все следующие объявленные в диалоге наборы данных с начального набора данных.

Пользователь, сформировавший задание, получает данные в телеграмме со следующим синтаксисом: DAEX  < Имя диалога > < Имя набора данных > | < Значение элемента данных > | < Значение элемента данных > ...


< Генерация случая входных данных>: FALLGEN < Операнд[ST_DE] > < Операнд[ST_DE] > < Операнд[ST_DE] >

FALLGEN: Сокращение(аббревиатура) команды для 'Сгенерировать случай входных данных для диалога'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Имя диалога, для которого должен быть сгенерирован случай входных данных.
2.) Сокращение(аббревиатура) действия, макс. 4 символа, которое должно быть представлено в секции "Ввод действия" для диалога, к которому производится обращение, если в него поступят входные данные, как в конкретном случае.
3.) ASCII-строка для передачи данных (макс. 100 символов).


< Достоверизация данных >: PLAUS < Операнд[DE_DS] >

PLAUS: Сокращение(аббревиатура) команды для 'Проверить достоверность объекта'.

Параметр означает следующее:

Имя объекта (набора или элемента данных), проверка достоверности которого должна быть выполнена. Знак здесь игнорируется.

На основе этого алгоритма в секции "Достоверизация" определяются все записи, имеющие отношение к объекту, и выполняется приведенная там последовательность.

При внешней проверке достоверности в течение времени ожидания в качестве ответа должна быть получена телеграмма:

< Задание на достоверизацию элемента данных > см. 1. 9 или < Задание на достоверизацию набора данных > см. 1. 10.

При внешней проверке достоверности пользователь, сформировавший задание, получает следующую телеграмму:

- при достоверизации набора данных:

PSAN < Имя даилога > < Имя набора данных > | < Значение элемента данных > | < Значение элемента данных > ...

- при достоверизации элемента данных:

PEAN < Имя диалога > < Имя набора данных >.< Значение элемента данных > | < Значение элемента данных >

Векторы наборов данных могут быть указаны с постоянной или переменной индексацией.


< Запрос текста справки >: HELPTXT < Операнд[IN_ST_DE] >

HELPTXT: Сокращение(аббревиатура) команды для 'Определить/найти текст справки'.

Параметр означает следующее:

Однозначный целочисленный номер текста справки, который должен быть задан в секции "Тексты справки".


На основе этого алгоритма с помощью номера берется начало текста справки в секции "Тексты справки" и сохраняется в автоматически объявленном наборе данных (HTEXTE "%5d" helpind) для возможного вывода текста. Графический вывод текста с этим не связан. Алгоритм текста справки может встречаться неоднократно с различными номерами во фрагменте задания. Но для (возможного) вывода (см. HELPEIN) используется, соответственно, только последняя запись.


< Определение текстов ошибок для данных >: FEHTXT < Операнд[DE_DS] > < Преобразование >

FEHTXT: Сокращение(аббревиатура) команды для 'Определить/найти текст ошибки для объекта'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Имя объекта (набора или элемента данных), чей статус (.STA) должен быть преобразован в текст ошибки. Знак здесь игнорируется.


2.) < Преобразование >: Имя алгоритма, который описывает, каким образом статус данных должен быть преобразован в номер ошибки. Этот алгоритм должен быть задан в секции "Преобразование ошибок".

Статус ошибки представленного объекта, определенный при проверке достоверности, на основе этого алгоритма преобразуется в номер ошибки. С помощью номера ошибки из секции "Тексты ошибок" берется текст, который сохраняется в имеющийся скрытый список и хранится там для возможного вывода (см. FEHEIN). В истории может храниться макс. 16 текстов. Если требуется сохранить другие ошибки, то список должен быть очищен вручную с помощью алгоритма FEHLOE. Графический вывод не связан с этим алгоритмом. Набор данных объявляется следующим образом:

FTEXTE "%d %d %80s %80s %80s %80s %80s %80s %80s %80s %80s %80s %80s %80s %80s %80s %80s %80s" anzahl lfnr zeile1  zeile2  zeile3  zeile4  zeile5  zeile6 zeile7  zeile8  zeile9  zeile10 zeile11 zeile12 zeile13 zeile14 zeile15 zeile16

anzahl : Количество находящихся в строках zeile1 - zeile16 текстов ошибок.


lfnr   : Номер последней преобразованной ошибки.

zeile1 ... zeile16: Строки текстов ошибок.


< Список ошибок_алгоритм удаления >: FEHLOE

Содержимое имеющегося скрытого списка FTEXTE удаляется. Это является предпосылкой для согласованного вывода ошибки, равно как и для алгоритма SCHRITTFEHLER. FTEXTE.anzahl устанавливается в "0", FTEXTE.lfnr устанавливается в "-1".


< Элемент данных_маркировка изменения >: < Операнд[EF] > = "0" oder "1"


< Набор данных_маркировка изменения >: < Операнд[SF] > = "0" oder "1"

Для всех элементов данных набора данных устанавливается, соответственно, маркировка изменения.


< Копия набора данных >: < Операнд[DS] > = < Операнд[DS] >

Оба набора данных должны иметь одинаковую структуру и одноимённые элементы. Знак первого набора данных игнорируется.

< Привязка/связь значений >: < Цель > = < Источник >

< Цель >: < Операнд[IN_WI_EF_SF_ES_DE] >

При привязке значений к статусу элемента данных статус набора данных определяется заново из статуса элемента данных. Знак строки игнорируется.

< Источник >: < Операнд[IN_WI_ST_EF_SF_ES_SS_DE] >


< Арифметический алгоритм >: < Цель > = < Источник > < Оператор > < Источник >

< Оператор >: + или
- или * или / или % или & или | или
^ или < или > или ? или @ или !

Для случая, когда все 3 участвующих операнда одного типа:

Тип = long : Операторы обозначают стандартные арифметические или логические операции + : сложение
- : вычитание * : умножение / : деление		a/b*b+a%b = a	!! % : модуль 		immer > 0	!! & : побитовая операция И | : побитовая операция ИЛИ
^ : побитовая операция ИСКЛЮЧАЩЕЕ ИЛИ ! : побитовая операция НЕ ИЛИ < : побитовое смещение влево > : побитовое смещение вправо ? : выбор бита: Все биты, установленные во втором операнде, импортируются из первого операнда и сжимаются вправо. Например, "40"   ? "10"   => "2"
101000 ? 001010 => 000010 @ : Результат всегда 0

Тип = double : Операторы & | ^ < > ? @ ! в качестве результата всегда дают 0, так как для этого типа они не заданы. Другие операторы действуют, как и для типа long.



Тип = String :

+ -> Связывание обеих строк в рамках последовательности операндов и ограничение по левому краю на конечную длину.
- -> Однократное удаление второй строки из первой, если это возможно. В противном случае - удаление первой строки. * -> Результат J, если 2я строка содержится впервой, в противном случае - N. / -> Результат J, если строки идентичны, +, если первая строка больше второй,
-, если первая строка меньше второй (strcmp) % -> Удаление первых der n-символов первой строки и выравнивание по левому краю, причем n представлено второй строкой. Если n < 0, то добавляется длина первой строки (либо длина строки, либо преобразованное числовое значение) Пример: "WALTER" % "AB" -> "LTER" "WALTER" % "-2" -> "ER"

& -> Импорт первых n-символов первой строки и выравнивание по левому краю, причем n представлено второй строкой. Если n < 0, то добавляется длина первой строки (либо длина строки, либо преобразованное числовое значение). Пример: "WALTER" & "AB" -> "WA" "WALTER" & "-2" -> "WALT"

| -> Циклическая замена символов второй строки знаками пробела в первой строке. Пример: "WALTER VON DER VOGELWEIDE" | "OD" -> "WALTER V N  ER V GELWEI E" Применяется, например в: Списке списков LL ="A,B,C X,Y,Z U,V,W" L1 =LL?"1" L1 =L1|"," E11=L1?"1"

^ -> Выбор тех символов первой строки, для которых во второй строке на соответствующей позиции находится символ, не равный " " , и выравнивание по левому краю. Пример: "WALTER" ^ " * * *" -> "ATR"

< -> Циклический сдвиг первой строки влево на столько позиций, сколько представлено во второй строке. (либо длина строки, либо преобразованное числовое значение. Если числовое значение отрицательное, то добавляется длина первой строки.) Пример: "WALTER" < "AB" -> "LTERWA" "WALTER" < "3"  -> "TERWAL" "WALTER" < "-2" -> "ERWALT"

> -> Циклический сдвиг первой строки вправо на столько позиций, сколько представлено во второй строке.(либо длина строки, либо преобразованное числовое значение. Если числовое значение отрицательное, то добавляется длина первой строки.) Пример: "WALTER" > "AB" -> "ERWALT" "WALTER" > "3"  -> "TERWAL" "WALTER" > "-2" -> "LTERWA"

? -> Выбор отсчитанной с 0 позиции n-ой подстроки из первой строки, причем <n> является значением второй строки. (либо длина строки, либо преобразованное числовое значение. Если числовое значение отрицательное, то добавляется количество подстрок первой строки.)

Подстрока - это строка, в которой отсутствуют символы пробела и которая ограничена с обеих сторон символом пробела или нулевым символом.

Пример: " WALTER VON DER VOGELWEIDE" ? "2"  -> "DER" " WALTER VON DER VOGELWEIDE" ? "-1" -> "VOGELWEIDE" " WALTER VON DER VOGELWEIDE" ? "0"  -> "WALTER" " WALTER VON DER VOGELWEIDE" ? "4"  -> "" " WALTER VON DER VOGELWEIDE" ? "TT" -> "DER" " WALTER VON DER VOGELWEIDE" ? ""   -> "WALTER"

@ -> Первая строка выбирается до n-й подстроки включительно, причем <n> является значением второй строки.(либо длина строки, либо преобразованное числовое значение. Если числовое значение отрицательное, то добавляется количество подстрок первой строки.)

Пример: " WALTER VON DER VOGELWEIDE" @ "2"
-> " WALTER VON DER" " WALTER VON DER VOGELWEIDE" @ "-2"
-> " WALTER VON DER" " WALTER VON DER VOGELWEIDE" @ "0"
-> " WALTER" " WALTER VON DER VOGELWEIDE" @ "3"
-> " WALTER VON DER VOGELWEIDE" " WALTER VON DER VOGELWEIDE" @ "4"
-> " WALTER VON DER VOGELWEIDE" " WALTER VON DER VOGELWEIDE" @ "T"
-> " WALTER VON" " WALTER VON DER VOGELWEIDE" @ ""
-> " WALTER"

! -> Первая строка выбирается с n-й подстроки включительно, причем <n> является значением второй строки.(либо длина строки, либо преобразованное числовое значение. Если числовое значение отрицательное, то добавляется количество подстрок первой строки.)

Пример: " WALTER VON DER VOGELWEIDE " ! "2"
-> "DER VOGELWEIDE " " WALTER VON DER VOGELWEIDE " ! "-2"
-> "DER VOGELWEIDE " " WALTER VON DER VOGELWEIDE " ! "0"
-> "WALTER VON DER VOGELWEIDE " " WALTER VON DER VOGELWEIDE " ! "3"
-> "VOGELWEIDE " " WALTER VON DER VOGELWEIDE " ! "4"
-> "" " WALTER VON DER VOGELWEIDE " ! "T"
-> "VON DER VOGELWEIDE " " WALTER VON DER VOGELWEIDE " ! ""
-> "WALTER VON DER VOGELWEIDE "


При смешанных типах операндов целевой операнд определяет значение оператора, а также тип результата. Если целевой (конечный) тип - String, то все операнды обрабатываются как строки. Если же целевой конечный) тип - double или long, то все числовые типы преобразуются с возможной потерей информации, String поступает с той же длиной, если он не должен быть полностью преобразован в целевой тип, в противном случае принимается преобразованное числовое значение.

< Алгоритм COPY >: COPY < Операнд[IN_DE] > < Операнд[IN_WI_ST_EF_SF_ES_SS_DE] > < Операнд[IN_WI_ST_EF_SF_ES_SS_DE] > < Операнд[IN_WI_ST_EF_SF_ES_SS_DE] > < Операнд[IN_WI_ST_EF_SF_ES_SS_DE] >

Параметры в вышеуказанной последовательности означают следующее:

1.) Цель: Операнд, который должен быть изменен с помощью алгоритма COPY

2.) Целочисленный индекс в цели (целевой индекс).

3.) Целое число

4.) Исходный операнд в алгоритме COPY (источник).

5.) Целочисленный индекс в источнике (индекс в источнике).

Алгоритм COPY изменяет содержимое цели. Используется источник с типом цели. В зависимости от типа цели алгоритм действует следующим образом:

a) Тип(цели) = Long:

Биты "Anzahl" источника, начиная с бита индекса источника, копируются в биты "Anzahl" цели, начиная с бита целевого индекса без изменения не участвующих при этом битов.

b) Тип(цели) = Double:

Цели присваивается значение 0.0.

c) Тип(цели) = String:

Символы "Anzahl" источника, начиная с индекса источника, копируются в символы "Anzahl" цели, начиная с целевого индекса без изменения не участвующих при этом символов и длины строки. Индексы больше длины строки источника или строки цели никакого действия не оказывают. Символы могут быть лишь заменены, а не добавлены.

< Алгоритм ENTHALTEN >: ENTHALTEN < Операнд[IN_DE] > < Операнд[IN_DE] > ( < Список сравниваемых строк > )

< Список сравниваемых строк >: < Сравниваемая строка > ... < Сравниваемая строка >

< Сравниваемая строка >: < Операнд[ST] >    или < Операнд[ST] > - < Операнд[ST] >


Алгоритм ищет значение в списке сравниваемых строк и выдает значение -1 , если значение не было представлено в списке, или относительную позицию (начиная с 0) той записи в списке сравниваемых строк, которая совпадает со значением. В списке сравниваемых строк может быть приведено от 0 до макс. 16 записей. Сравниваемая строка является либо строковой константой (String), либо областью, которая задана двумя строковыми константами. Область включает границы и записывается с помощью символа "-" между строковыми константами. Границы области должны монотонно возрастать. Тип искомого значения определяет вид сравнения.

Для типов long или double выполняется проверка равенства(тождественности), для области: нижняя граница <= значение <= верхняя граница.

Для типа string выполняется проверка совпадения содержимого строк или для области: strcmp (значение, нижняя граница) >= 0 && strcmp (значение,верхняя граница) <= 0.

Параметры в вышеуказанной последовательности означают следующее:

1.) Операнд, которому присваивается результат сравнения.

2.) Операнд, который содержит искомое значение.

Следующие параметры (от 0 до макс.16) представляют значения сравнения или области.


Пример: daten.wert = "23" ENTHALTEN ergebnis daten.wert ("40""23""10"-"11""100"-"200")

ergebnis имеет значение "1" Для daten.wert = "150" ergebnis имеет, например, значение "3"


< Алгоритм ROTATION >: ROTATION < Операнд[DS_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] >


Алгоритм применяется только для векторов наборов данных и элементов данных.

Пример:    dsvektor[0] dsvektor[4] dsvektor[ind] ds.devektor[0] ds.devektor[3] ds.devektor[ind] dsvektor[ind].devektor[0] dsvektor[ind].devektor[ind1] dsvektor[3].devektor[ind]

Параметры в вышеуказанной последовательности означают следующее:

1.) Первый элемент вектора наборов или элементов данных, начиная с которого должно быть выполнено вращение.

2.) Количество элементов вектора, участвующих во вращении, начиная с первого элемента

3.) Сдвиг вращения.

Алгоритм циклически соподчиняет индексированным объектам содержимое тех объектов, индекс которых отличается на сдвиг вращения. Направление вращения определяется знаком сдвига.

Пример:

dsvektor[3] "%d" wert

ROTATION dsvektor[0] "3" "1"   ->

dsvektor[0] <- dsvektor[1] <- dsvektor[2] <- dsvektor[0]

ROTATION dsvektor[0] "3" "-1"   ->

dsvektor[0] -> dsvektor[1] -> dsvektor[2] -> dsvektor[0]

ROTATION dsvektor[1] "2" "1"   ->

dsvektor[1] <- dsvektor[2] <- dsvektor[1]

Если сдвиг вращения = 0, то алгоритм не оказывает никакого действия. Если число вращений <= 1, то алгоритм не оказывает никакого действия.

ROTATION dsvektor[x] "y" "a" равно ROTATION dsvektor[x] "y" "b", если b = a + n*y. n является целым числом.

Пример:

dsvektor[3] "%d" wert

Алгоритмы   ROTATION dsvektor[0] "3" "-1" и ROTATION dsvektor[0] "3" "2" являются одинаковыми по своему действию.

Для ROTATION dsvektor[x] "y" "a" всегда справедливо: x + y <= размерность вектора.


< Алгоритм SUCHE >: SUCHE < Операнд[DS_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] >


Адгоритм применяется только для векторов наборов или элементов данных.

Пример:    dsvektor[0] dsvektor[4] dsvektor[ind] ds.devektor[0] ds.devektor[3] ds.devektor[ind] dsvektor[ind].devektor[0] dsvektor[ind].devektor[ind1] dsvektor[3].devektor[ind] dsvektor[0].attribut

Параметры в вышеуказанной последовательности означают следующее:

1.) Первый элемент вектора наборов или элементов данных, начиная с которого должен выполняться поиск. Если речь не идет о векторе, то переходы осуществляются по наборам данных.

2.) Количество проанализированных в результате поиска элементов вектора, начиная с первого элемента.

3.) Операнд, который содержит искомое значение.

4.) Операнд, которому должно быть присвоен результат поиска.

Алгоритм линейно ищет переданное значение внутри вектора и возвращает -1, если значение не было найдено, или индекс, начиная с первого элемента. Если текст сравнивается с числом, то длина текста участвует в сравнении. Если операнд типа Text, но содержит число, то выполняется его поиск.


Пример 1:

dsvektor      "%d" wert[3]

dsvektor.wert[0] = "1" dsvektor.wert[1] = "2" dsvektor.wert[2] = "3"

SUCHE dsvektor.wert[0] "3" "2" meinindex
-> meinindex = "1"

SUCHE dsvektor.wert[1] "2" "2" meinindex
-> meinindex = "0"


Пример 2:

dsdevektor[3] "%d" wert[2]

dsdevektor[0].wert[0] = "1" dsdevektor[0].wert[1] = "2" dsdevektor[1].wert[0] = "3" dsdevektor[1].wert[1] = "4" dsdevektor[2].wert[0] = "5" dsdevektor[2].wert[1] = "6"

SUCHE dsdevektor[0] "6" "5" meinindex
-> meinindex = "4"

SUCHE dsdevektor[1] "5" "5" meinindex
-> meinindex = "2"



1.11.14.4.2.2  Условные алгоритмы

Существуют следующие условные алгоритмы :

< условный алгоритм > < альтернативный вызов макроса > < условное завершение макроса > < условный макрос/прерывание цикла >


< условный алгоритм >: ( < Операнд[IN_WI_ST_EF_SF_ES_SS_DE] > < Оператор сравнения > < Операнд[IN_WI_ST_EF_SF_ES_SS_DE] > ) ? < Алгоритм > : < Алгоритм >

< Оператор сравнения >: == или != или >= или <= или >  или <

Для типов элементов данных применяется так же, как и в арифметических алгоритмах. Тип данных определяется по первому операнду в скобках условия.

< Алгоритм >:
-    или один из заданных в разделе "Тип шага_фрагмент" алгоритмов.

Если условие выполнено, то выполняется первый приведенный алгоритм, в противном случае - второй. При использовании "-" обработка алгоритма отсутствует.


< альтернативный вызов макроса >: AUSWAHL < операнд[IN_WI_ST_EF_SF_ES_SS_DE] > ? < Альтернативный макрос_1 > : < Альтернативный макрос_2 > : ... # < Макрос по умолчанию >

< Альтернативный макрос_n >:
-    или идентификатор макроса алгоритма

< Макрос по умолчанию >:
-    или идентификатор макроса алгоритма

Идентификатор макроса алгоритма. Если локальный макрос не найден, то он понимается как глобальный, который должен быть задан в секции "Макросы алгоритмов".

Содержимое операнда понимается в качестве критерия выбора альтернатив. Если значение критерия выбора меньше 0 или больше количества указанных альтернативных макросов, то в конце списка выполняется макрос по умолчанию, находящийся в конце списка и помеченный #.

Должны быть заданы по крайней мере один альтернативный макрос и макрос по умолчанию. Может быть указано макс. 255 альтернативных макросов.

При использовании "-" обработка макроса отсутствует. Должен быть указан по меньшей мере один макрос алгоритма.


< условное завершение макроса >: RETURN ( < Операнд[IN_WI_ST_EF_SF_ES_SS_DE] > < Оператор сравнения > < Операнд[IN_WI_ST_EF_SF_ES_SS_DE] > )  или

RETURN

Если алгоритм не находится в макросе, то он не оказывает никакого действия. Сначала проверяется условие, если оно есть. Если условие отсутствует, то считается, что все условия выполнены. Если условие не выполнено, но алгоритм не оказывает никакого действия. При выполненном условии текущий вызванный макрос завершается. Внимание: За RETURN без условия не может следовать условный алгоритм!

< условный макрос/прерывание цикла >: BREAK ( < Операнд[IN_WI_ST_EF_SF_ES_SS_DE] > < Оператор сравнения > < Операнд[IN_WI_ST_EF_SF_ES_SS_DE] > )  или BREAK

Если алгоритм не находится в макросе, то он не оказывает никакого действия. Сначала проверяется условие, если оно есть. Если условие отсутствует, то считается, что все условия выполнены. Если условие не выполнено, но алгоритм не оказывает никакого действия. Если условие выполнено, то все макросы, в результате вызова которых был достигнут алгоритм, сразу прерываются без использования их логических выходов. Если в последовательности вызовов есть цикл, то он также спорадически завершается, однако никакой другой, иерархически выше расположенный макрос не прерывается. Обработка устанавливаетя сразу после алгоритма цикла. Если в последовательности вызовов цикл отсутствует, то все вызванные макросы завершаются спорадически. Внимание: За BREAK без условия не может следовать условный алгоритм!

1.11.14.4.2.3  ZDM_DIA_алгоритм

Некоторые известные ЦДД задания действий, которые относятся к окнам, могут использоваться DIATом. Они обрабатываются ЦДД и отправляются назад DIATу в качестве полноценных заданий действий, который обрабатывает их по вводу действия. Синтаксис:

ZDMDIA < Задание > < Окно > < Операнд[IN_WI_ST_DE] > ...

ZDMDIA: Сокращение(аббревиатура) команды для 'Отправить действие в диалог ЦДД'.

< Задание >: Возможны следующие ключевые слова:

OPWT (12 Параметр : Открыть окно какого-либо типа) OPSW (12 Параметр : Открыть стандартное окно) CLWI ( 1 Параметр : Закрыть окно) VGWI ( 0 Параметр : Перенести окно на передний план) HGWI ( 0 Параметр : Перенести окно на задний план) ICWI ( 3 Параметр : Свернуть окно в иконку) MVWI ( 2 Параметр : Переместить окно) RSWI ( 2 Параметр : Изменить размер окна) AKWI ( 0 Параметр : Активировать окно) LBBC ( 9 Параметр : Загрузить изображение в контейнер изображений в окне) MRWI ( 4 Параметр : Сдвинуть окно и изменить его размер Внутренний алгоритм DIAT) CTWT ( 3 Параметр : Триггировать окно)

< Окно >: Идентификатор окна, к которому относится действие.

Параметры имеют значения в соответствии с действиями. Пояснение находится в описании ЦДД.

Замечание! В OPSW и OPWT дополнительно может быть указан WIDF. Так как в синтаксисе файлов управления не разрешены другие дополнительные параметры, то WIDF нужно прикрепить к последнему параметру. Параметры передаются напрямую ЦДД.

Пример: tmp.str = "1 " + tmp.str ... ZDMDIA OPSW ... "meinlayout.lay" tmp.str

В связи с ZDM_DIA_алгоритмом квитирование ЦДД отправляется обратно DIATу. DIAT генерирует из этого случай входного действия.

Все известные ЦДД действия могут быть отправлены ему с помощью алгоритма AKTDIA. Они обрабатываются ЦДД и отправляются назад DIATу в качестве полноценных заданий действия, который обрабатывает их по вводу действия. Синтаксис:

AKTDIA < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] >

AKTDIA: Сокращение(аббревиатура) команды для 'Отправить действие в ЦДД'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Номер действия, которое должно быть выполнено (см. описание ЦДД)

2.) Абсолютный номер монитора, к которому должно относиться действие. Каждое действие относится к монитору, даже если действие не является графическим.

3.) Необходимые в соответствии с действием параметры. Они обрабатываются как одна связанная строка параметров. Если требуется только один параметр и он является числом, то может быть принят индекс или элемент данных соответствующего типа, в противном случае для приема нескольких параметров должна использоваться строка или элемент данных типа %<n>s.

1.11.14.4.2.4  ZDM_ABW_алгоритм

Некоторые известные ЦДД задания действий, которые относятся к окнам, могут использоваться DIATом. Они обрабатываются исполнительным устройством ЦДД и должны быть полностью запараметрированы. Они не квитируются и не отсылаются обратно DIATу.


ZDMABW < Задание > < Окно > < Операнд[IN_WI_ST_DE] > ...

ZDMABW: Сокращение(аббревиатура) команды для 'Отправить действие исполнительному устройству ЦДД'.

< Задание > , < Окно > и < Операнд[IN_WI_ST_DE] > ... означают то же самое, что и для алгоритма ZDMDIA.


Все известные ЦДД действия могут быть отправлены испольнительному устройству ЦДД с помощью алгоритма AKTABW. Они обрабатываются исполнительным устройством ЦДД и должны быть полностью запараметрированы. SОни не квитируются и не отсылаются обратно DIATу.

Синтаксис:

AKTABW < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] >

AKTABW: Сокращение(аббревиатура) команды для 'Отправить действие испольнительному устройству ЦДД'.

Параметры означают то же самое, что и в алгоритме AKTDIA.


1.11.14.4.2.5  Графические алгоритмы

Существует набор алгоритмов для управления графическими свойствами элементов управления, а также для управления ситуацией в окне.

SITUATION < Операнд[WI] > < Операнд[IN_ST_DE] >

SITUATION: Сокращение(аббревиатура) команды для 'Установить ситуацию в окне'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Имя окна, в котором должна быть установлена ситуация.

2.) Номер ситуации, которую необходимо установить. Целое число от 0 до 31. Ситуация должна соответствовать действительной ситуации в шаблоне окна.

Каждый элемент управления имеет критерии видимости и идентификации. Они реализованы с помощью 4х битовых строк по 32 бита каждая. Из них 2 битовых строки являются статическими(видимость и возможность идентификации). Они задаются по умолчанию для каждого элемента управления в файле шаблона. В нормальном случае эти две статических битовых строки вместе с ситуацией в окне определяют видимость и возможность идентификации каждого элемента управления.

Элемент управления является статически видимым, если бит со значением ситуации установлен в битовой строке видимости.

Элемент управления является статически идентифицируемым, если бит со значением ситуации установлен в битовой строке идентификации.

Существуют две другие битовые строки, содержимое которых может быть предустановлено динамически и которые могут использоваться вместо статических. При настройке параметра режима каждого элемента управления может быть задано, используется ли статическое или динамическое управление ситуацией.

SICHTBAR < Операнд[WI] > < Операнд[IN_ST_DE] >

SICHTBAR: Сокращение(аббревиатура) команды для 'Видимость окна'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Имя окна, которое должно стать видимым/невидимым.

2.) Метка видимости ("N" или "S" (все остальное в качестве "S"))

"N" : окно не видимо. "S" : окно видимое.


STATUS < Имя блока > < Операнд[IN_ST_DE] >

STATUS: Сокращение(аббревиатура) команды для 'Установить статус в блоке статусов элементов управления'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Имя блока статусов элементов управления, в котором для всех соподчиненных ему элементов управления должен быть установлен соответствующий статус, определенный из номера версии. Блок должен быть задан секции "Блок статусов элементов управления"

2.) Номер версии конфигурации статуса, предназначенного для установки. Целое число от 0 до 9. Номер версии определяет индекс элемента из списка статусов для каждого элемента управления, который, в свою очередь, является элементом блока. Выбранный статус каждого элемента управления передается графическому изображению.



ANZEIGE_AKTIV ANZEIGE_PASSIV

Для каждого диалога в DIATе есть внутренний флаг, который определяет, связано ли графическое обновление с графическим алгоритмом или нет. Этот флаг автоматически установлен (активен), но может быть изменен с помощью следующих алгоритмов: ANZEIGE_AKTIV ANZEIGE_PASSIV.


ANZEIGE_AKTIV включает обновление, пока действие не будет отменено. Обновление предшествующих графических алгоритмов не связано с этим алгоритмом. Все последующие графические алгоритмы сразу же обновляются.

ANZEIGE_PASSIV отключает обновление, пока действие не будет отменено. Все графические алгоритмы выполняются на заднем плане в невидимом режиме. Чтобы результат сделать видимым, должна быть выполнена опция ANZEIGE в алгоритме GRAFIK, которая относится ко всем элементам управления, к отдельным окнам или к касающемуся элементу управления.


FEHEIN < Элемент управления >

< Элемент управления >: Имя элемента управления, объявленного в секции "Элементы управления" или < Имя вектора >

В элементе управления отображается текст ошибки, находящийся в FTEXTE. Алгоритм действует только для элементов управления типа TEXTOUT, TEXTOUTVEK, TEXTOUTIN и TEXTOUTINVEK. Для элементов управления типа TEXTOUT и TEXTOUTIN выводится только последний текст ошибки из списка FTEXTE. Для элементов управления типа TEXTOUTVEK и TEXTOUTINVEK выводятся все тексты ошибок (Внимание, так как список FTEXTE может содержать макс. 16 записей, а элемент управления тогда должен иметь по крайней мере 16 субобъектов!).


HELPEIN < Элемент управления >

В элементе управления отображается текст справки, определенный с помощью HTEXTE. Алгоритм действует только для элементов управления типа TEXTOUT, TEXTOUTVEK, TEXTOUTIN und TEXTOUTINVEK. Для элементов управления типа TEXTOUT и TEXTOUTIN выводится только первая строка текста справки. Для элементов управления типа TEXTOUTVEK и TEXTOUTINVEK выводятся все строки текста справки (Внимание, так как тексты справки могут состоять макс. из 32 строк, а элемент управления тогда должен иметь по меньшей мере 32 субобъекта!).



TEXTAUS < Элемент управления >

В элементе управления удаляется текст. Алгоритм действует только для элементов управления типа TEXTOUT, TEXTOUTVEK, TEXTOUTIN и TEXTOUTINVEK.

Следующие графические алгоритмы управляют выводом текста, изменением статуса, параметрами полос прокрутки, выводом списков и параметрами элементов управления, причем указанные в алгоритмах субобъекты обрабатываются только тогда, когда элемент управление, к которому выполнено обращение, содержит субобъекты:


GRAFIK ( < Элемент управления > TEXT < Операнд[IN_ST_DE] > < Операнд[IN_WI_ST_DE] > )

Алгоритм действует только для элементов управления типа TEXTOUT и TEXTOUTVEK. Для элементов управления типа TEXTOUTVEK текст выводится в каждом элементе вектора.

Параметры в вышеуказанной последовательности означают следующее:

1.) Субобъект или -1.
-1: Алгоритм относится ко всему элементу управления. n : Алгоритм относится к n-ому субобъекту элемента управления.

2.) Текст, который необходимо вывести в конкретной позиции субобъекта.


GRAFIK ( < Элемент управления > TEXTLISTE < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > )

Алгоритм действует только для элементов управления типа TEXTOUTVEK.

Параметры в вышеуказанной последовательности означают следующее:

1.) Начальная строка элемента управления списком. Если элемент управления типа VEKBED, то алгоритм применяется к соответствующему элементу управления. Если же речь при этом идет об элементе управления типа TEXTOUTVEK, то алгоритм относится к элементу управления, указанному под п.2. Коэффициент приращения строки всегда 1!

2.) Приращение строки в элементе управления списком.

3.) Количество предназначенных для вывода строк.

4.) Объект, который содержит первый предназначенный для вывода текст. (текс для начальной строки)

5.) Режим приращения объекта ("E" или "S" (все остальное в качестве "S"))


"E" : внутри набора данных в объекте 4.) переход выполняется по элементам. Если набор данных содержит слишком мало элементов данных, то переход прерывается на последнем элементе.

"S" : внутри диалога переход выполняется по наборам данных в порядке их объявления, причем всегда берется именно тот элемент данных, который занимает ту же самую относительную позицию в наборе данных, что и объект в 4.). Если в распоряжении находится слишком мало наборов данных, то переход прерывается на последнем наборе данных.

6.) Значение приращения объекта(т.е. шаг), на которое осуществляется переход по элементам или по наборам данных.


GRAFIK ( < Элемент управления> TSM < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > )

TSM-алгоритм (Text_Shift_Mode-алгоритм) служит для установки режима прокрутки для горизонтального пролистывания в элементе управления типа TEXTOUT и TEXTOUTVEK. Для элементов управления типа TEXTOUTVEK в каждом элементе вектора устанавливается одинаковый режим.

Параметры в вышеуказанной последовательности означают следующее:

1.) Субобъект или -1.
-1: Алгоритм относится ко всему элементу управления. n : Алгоритм относится к n-ому субобъекту элемента управления.

2.) Режим прокрутки
0 : Горизонтальная прокрутка невозможна.
1 : Текст смещается на n (значение прокрутки) символов.
2 : Текст смещается до ASCII-символа z (значение прокрутки) и отображается, включая z.
3 : Текст смещается до ASCII-символа z (значение прокрутки) и отображается, не включая z, до следующего z.

3.) Значение прокрутки Интерпретация согласно режиму прокрутки. Режим 0 : Dummy Режим 1 : Кол-во символов Режим 2 : ASCII-символ для отображения Режим 3 : ASCII-символ в качестве разделителя

4.) Позиция прокрутки p, начиная с которой текст должен быть отображен в зависимости от настройки режима. Режим прокрутки влияет на позицию прокрутки. Режим 0 : Dummy Режим 1 : p символов Режим 2 : p * ASCII-символ для отображения Режим 3 : p * ASCII-символ в качестве разделителя


GRAFIK ( < Элемент управления > SRM < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > )

Алгоритм действует только для элементов управления типа TEXTOUTIN и TEXTOUTINVEK. Для элементов управления типа TEXTOUTINVEK в каждом элементе вектора выводится текст вопроса и текст ответа.

Параметры в вышеуказанной последовательности означают следующее:

1.) Субобъект или -1.
-1: Алгоритм относится ко всему элементу управления. n : Алгоритм относится к n-ому субобъекту элемента управления.

2.) Текст вопроса

3.) Текст ответа

4.) Режим Echo(E: Echo с подчеркиванием L: Echo без подчеркиванием P: Echo и подчеркивания нет в противном случае: Echo от '*' с подчеркиванием)

5.) Позиция курсора записи (цифра или E : конец)

6.) Макс. длина ввода l l < 0 : Макс. длина ввода не установлена, (автоматический возврат(Return) отсутствует, автоматический Passiv при возврате(Return)). l = 0 : Макс. длина ввода не установлена, (автоматический возврат(Return) после каждого изменения, но автоматический Passiv отсутствует).
0 < l <= заданная макс. длина ввода в файле шаблона : Макс. длина ввода устанавливается в l. (автоматический возврат(Return) отсутствует, автоматический Passiv при возврате(Return)). l > заданная макс. длина ввода в файле шаблона : Макс. длина ввода является действительной/достоверной. (автоматический возврат(Return) отсутствует, автоматический Passiv при возврате(Return)).


GRAFIK ( < Элемент управления > FLAGS < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > )

Параметры в вышеуказанной последовательности означают следующее:

1.) Субобъект или -1.
-1: Алгоритм относится ко всему элементу управления. n : Алгоритм относится к n-ому субобъекту элемента управления.

2.) Маска флага, которую нужно установить

Алгоритм действует только для элементов управления типа TEXTOUTFL и TEXTOUTFLVEK.


GRAFIK ( < Элемент управления > FLAGSLISTE < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > )

Алгоритм действует только для элемента управления типа TEXTOUTFLVEK.

Параметры в вышеуказанной последовательности означают следующее:

1.) Начальная строка элемента управления списком

2.) Приращение строки в элементе управления списком

3.) Количество предназначенных для вывода масок флагов

4.) Объект, который содержит первую маску флага, предназначенную для вывода. (флаги для начальной строки)

5.) Режим приращения объекта ("E" или "S" (все остальное в качестве "S"))

"E" : внутри набора данных в объекте 4.) переход выполняется по элементам. Если набор данных содержит слишком мало элементов данных, то переход прерывается на последнем элементе.

"S" : внутри диалога переход выполняется по наборам данных в порядке их объявления, причем всегда берется именно тот элемент данных, который занимает ту же самую относительную позицию в наборе данных, что и объект в 4.). Если в распоряжении находится слишком мало наборов данных, то переход прерывается на последнем наборе данных.

6.) Значение приращения объекта(т.е. шаг), на которое осуществляется переход по элементам или по наборам данных.


GRAFIK ( < Элемент управления > STATUS < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > )

Параметры в вышеуказанной последовательности означают следующее:

1.) Субобъект или -1.
-1: Алгоритм относится ко всему элементу управления. n : Алгоритм относится к n-ому субобъекту элемента управления.

2.) Интеракционный статус, который необходимо включить(0 до n)


GRAFIK ( < Элемент управления > STATUSLISTE < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > )

Алгоритм действует только для элементов управления типа CONTAINERVEK, GRAFIKVEK, BALKENVEK, SLIDERVEK, TEXTOUTVEK, PICTUREVEK, TIMEDVEK, TEXTOUTINVEK, KUCONTVEK, TEXTOUTFLVEK или DRAWVEK.

Параметры в вышеуказанной последовательности означают следующее:

1.) Начальная строка элемента управления списком Если элемент управления типа VEKBED, то алгоритм применяется к соответствующему элементу управления. Если же речь при этом идет об элементе управления типа TEXTOUTVEK, то алгоритм относится элементу управления, указанному под п.2. Коэффициент приращения строки всегда 1!

2.) Приращение строки в элементе управления списком.

3.) Количество предназначенных для вывода статусов.

4.) Объект, который содержит первый предназначенный для вывода статус. (текс для начальной строки)

5.) Режим приращения объекта ("E" или "S" (все остальное в качестве "S"))

"E" : внутри набора данных в объекте 4.) переход выполняется по элементам. Если набор данных содержит слишком мало элементов данных, то переход прерывается на последнем элементе.

"S" : внутри диалога переход выполняется по наборам данных в порядке их объявления, причем всегда берется именно тот элемент данных, который занимает ту же самую относительную позицию в наборе данных, что и объект в 4.). Если в распоряжении находится слишком мало наборов данных, то переход прерывается на последнем наборе данных.

6.) Значение приращения объекта(т.е. шаг), на которое осуществляется переход по элементам или по наборам данных.



GRAFIK ( < Элемент управления > FOKUS < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > )

Алгоритм действует только для элементов управления типа TEXTOUTIN и TEXTOUTINVEK.

Параметры в вышеуказанной последовательности означают следующее:

1.) Субобъект или -1.
-1: Алгоритм относится ко всему элементу управления. n : Алгоритм относится к n-ому субобъекту элемента управления.

2.) Inputfokus ("AKTIV" или "PASSIV" (все остальное в качестве "PASSIV"))

Алгоритм устанавливает Inputfokus указанного объекта в "AKTIV" или "PASSIV". DIAT следит за тем, чтобы в окне был активирован, соответственно, только один Inputfokus. Inputfokus элемента управления зависит от его статуса.


GRAFIK ( < Элемент управления > PAR < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > )

Алгоритм действует только для элементов управления типа CONTAINERVEK, SYMBOLVEK, BALKENVEK, SLIDERVEK, TEXTOUTVEK, PICTUREVEK, TEXTOUTTIMEDVEK, TEXTOUTINVEK, KUCONTVEK, TEXTOUTFLVEK и DRAWVEK.

1.) Субобъект или -1.
-1: Алгоритм относится ко всему элементу управления. n : Алгоритм относится к n-ому субобъекту элемента управления.

2.) Параметр 0 : Первый видимый элемент вектора (first_visible).

3.) Параметр 1 :  "0" игнорировать nx, ny "1" импортировать новый nx,ny (matrix_flag) "2" импортировать новый nx,ny и переменное (изменяющееся) распределение

4.) Параметр 2 : Кол-во элементов вектора в направлении X (nx). При переменном распределении: nx<=0: игнорировать nx nx> 0: распределение в следующих nx элементах наборов данных.
5.) Параметр 3 : Кол-во элементов вектора в направлении Y (ny). При переменном распределении: ny<=0: игнорировать ny ny> 0: распределение в следующих ny элементах наборов данных.


GRAFIK ( < Элемент управления > ANZEIGE < Операнд[IN_ST_DE] > )

Параметры в вышеуказанной последовательности означают следующее:

1.) Субобъект или -1 или W или D.
-1: Алгоритм относится ко всему элементу управления. n : Алгоритм относится к n-ому субобъекту элемента управления. W : Алгоритм относится к окну, в котором объявлен субобъект. D : Алгоритм относится к диалогу, в котором объявлен субобъект. 'W' и 'D' справедливы только для реальных элементов управления. В случае вектора элементов управления действуют аналогично тому, как при -1.


GRAFIK ( < Элементы управления > BALKEN < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > )

Алгоритм действует только для элементов управления типа BALKEN и BALKENVEK. Для элементов управления типа BALKENVEK в каждом элементе вектора выводится средняя позиция полосы прокрутки и ее длина.

Параметры в вышеуказанной последовательности означают следующее:

1.) Субобъект или -1.
-1: Алгоритм относится ко всему элементу управления. n : Алгоритм относится к n-ому субобъекту элемента управления.

2.) Позиция середины полосы прокрутки (от 0 до 10000)

3.) Длина полосы прокрутки (от 0 до 10000)


GRAFIK ( < Элемент управления > SLIDER < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > )

Алгоритм действует только для элементов управления типа SLIDER и SLIDERVEK. Для элементов управления типа SLIDERVEK в каждом элементе вектора выводится информация.

Параметры в вышеуказанной последовательности означают следующее:

1.) Субобъект или -1.
-1: Алгоритм относится ко всему элементу управления. n : Алгоритм относится к n-ому субобъекту элемента управления.

2.) Метка_вкл_слайдера ("E" или "A" (все остальное в качестве "A")) "E" : слайдер включен "A" : слайдер выключен

3.) Формат вывода текста (количество символов после запятой или "L") Количество символов после запятой : вывод производится в формате Float с указанным количеством символов после запятой. "L" или количество<0              : вывод производится в формате Long.

4.) Минимальное значение слайдера (в зависимости от формата вывода текста: Float или Long)
5.) Текущее значение слайдера (в зависимости от формата вывода текста: Float или Long)

6.) Максимальное значение слайдера (в зависимости от формата вывода текста: Float или Long)


GRAFIK ( < Элемент управления > FARBE < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > )


Алгоритм действует только для элементов управления с индивидуальными цветами.

Параметры в вышеуказанной последовательности означают следующее:

1.) Субобъект или -1.
-1: Алгоритм относится ко всему элементу управления. n : Алгоритм относится к n-ому субобъекту элемента управления.

2.) Статус элемента управления

3.) Строка с новыми цветами элемента управления Структура строки : "<ColDef>{,<ColDef>}" Структура <ColDef>: "[SE:][T]n[B]" где: SE = BD|BG|UL|LR|FG	или SE = BD|BG|UL|LR|F1|F2|F3	для SCROLLPAN-BAR T  = W|L n  = 0..15 bei T=W или 0..7 для T=L W=(Black ,DGray ,LGray ,White , DRed  ,Red   ,Orange,Yellow, Green ,DGreen,LBlue ,Blue  , Violet,Free1 ,Free2 ,Free3 ) L=(Black,DGray,Gray,LGray,White,Select,Spezial) B  = N|S|F|T  (T только при SE=Fx / F только для T=W) N=Normal,S=Slow,F=Fast,T=Transparent по умолчанию: SE=BG T=W B=N


GRAFIK ( < Элемент управления > FARBLISTE < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > )

Алгоритм действует только для элементов управления с индивидуальными цветами.

Параметры в вышеуказанной последовательности означают следующее:

1.) Начальная строка элемента управления списком.

2.) Приращение строки в элементе управления.

3.) Количество предназначенных для вывода цветов.

4.) Статус элемента управления.

5.) Объект, который содержит первое задание цвета, предназначенное для использования (см. FARBE)

6.) Режим приращения объекта ("E" или "S" (все остальное в качестве "S"))

"E" : внутри набора данных в объекте 4.) переход выполняется по элементам. Если набор данных содержит слишком мало элементов данных, то переход прерывается на последнем элементе.

"S" : внутри диалога переход выполняется по наборам данных в порядке их объявления, причем всегда берется именно тот элемент данных, который занимает ту же самую относительную позицию в наборе данных, что и объект в 4.). Если в распоряжении находится слишком мало наборов данных, то переход прерывается на последнем наборе данных.

7.) Значение приращения объекта(т.е. шаг), на которое осуществляется переход по элементам или по наборам данных.


GRAFIK ( < Элемент управления > SITDYN < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > )

Алгоритм действует для элементов управления всех типов.

Параметры в вышеуказанной последовательности означают следующее:

1.) Субобъект или -1.
-1: Алгоритм относится ко всему элементу управления. n : Алгоритм относится к n-ому субобъекту элемента управления.

2.) Битовая строка видимости динамической ситуации элемента управления в файле шаблона окна.

3.) Битовая строка возможности идентификации динамической ситуации элемента управления в файле шаблона окна.


GRAFIK ( < Элемент управление > MODUS < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > )

Алгоритм действует для элементов управления всех типов.



Параметры в вышеуказанной последовательности означают следующее:

1.) Субобъект или -1.
-1: Алгоритм относится ко всему элементу управления. n : Алгоритм относится к n-ому субобъекту элемента управления.

2.) Номер режима обработки ситуации.
0 -> всегда видимо и идентифицируемо
1 -> всегда видимо и не идентифицируемо
2 -> статическая битовая строка
3 -> динамическая битовая строка Все остальное устанавливается в значение 2.


GRAFIK ( < Элемент управления > POOL < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[DE] > < Операнд[IN_ST_DE] > )

Алгоритм действует только для элементов типа CONTAINERVEK, GRAFIKVEK, BALKENVEK, TEXTOUTVEK, PICTUREVEK, TIMEDVEK, TEXTOUTINVEK, KUCONTVEK, TEXTOUTFLVEK или DRAWVEK.

Он приводит к изменению данных в Menuepool элемента управления, если меню задано в шаблоне. Menuepool содержит список номеров субобъектов элементов управления и управляет графическим расположением субобъектов таким образом, что они зависят не напрямую от номера субобъекта, а от их очередности в меню.

Параметры в вышеуказанной последовательности означают следующее:

1.) Начальный индекс Menuepool Внутри набора данных в объекте 3.) переход выполняется по элементам. Если набор данных содержит слишком мало элементов данных, то переход прерывается на последнем элементе.

2.) Количество значений, которые должны быть изменены в Menuepool

3.) Объект, который содержит первый номер субобъекта. (номер субобъекта для начального индекса)

4.) Общее количество достоверных/действительных значений в Menuepool.


GRAFIK ( < Имя вектора > BLAETTERN < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > )

Алгоритм действует только для вектора элементов обновления для обновления кнопок и полосы прокрутки при пролистывании списка. Отображение фрагмента списка, который определяется номером строки, не входит в этот алгоритм.

Вектор элементов управления должен состоять из 5 следующих элементов управления в заданном (предустановленном) порядке:

a) Полосы прокрутки (тип полосы в шаблоне: ZOOM).  (BALKEN) b) Кнопка для постраничного перелистывания вверх.  (GRAFIK) c) Кнопка для постраничного перелистывания вниз. (GRAFIK) d) Кнопка для построчной прокрутки вверх.  (GRAFIK) e) Кнопка для построчной прокрутки вниз. (GRAFIK)

Заданный в файле шаблона статус вышеупомянутого элемента управления должен соответствовать следующей предустановке:

можно выбрать -> 2, нельзя выбрать -> 1

Параметры в вышеуказанной последовательности означают следующее:

1.) Субобъект или -1. Разрешено только -1, все остальное воспринимается также в качестве -1.

2.) Номер строки списка, которая должна быть отображена в качестве первой строки на текущей странице списка.

3.) Количество строк в одной странице списка.

4.) Целое число строк списка.


GRAFIK ( < Элемент управления > SYMBOL < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[ST_DE] > < Операнд[IN_ST_DE] > )

Алгоритм действует только для элементов управления типа SYMBOL и SYMBOLVEK и служит для вывода заданных или самостоятельно созданных символов. Для элементов управления типа SYMBOLVEK в каждом элементе вектора отображается символ.

Параметры в вышеуказанной последовательности означают следующее:

1.) Субобъект или -1.
-1: Алгоритм относится ко всему элементу управления. n : Алгоритм относится к n-ому субобъекту элемента управления.

2.) Номер символа, который должен быть отображен в элементе управления (см. описание графического интерфейса или GrGraphic.h).

3.) Имена файлов, отделенные с помощью ',' или "" Этот параметр обрабатывается, только если должны отображаться собственные битовые карты(32)/Xpm(44) (см. описание графического интерфейса). Если указано больше 1 файла, то выполняется переключение статусом.

4.) Режим вывода или "" Этот параметр обрабатывается, только если должна быть отображена собственная битовая карта (см. описание графического интерфейса).


GRAFIK ( < Элемент управления > XSYNC < Операнд[IN_ST_DE] > )

Алгоритм служит для синхронизации с графическим сервером или для запроса на наличие элемента управления в используемом шаблоне.

Параметр означает следующее:

1.) Значение (>= 0) без семантики, которое отражается с G_ObjSynchronizeReply. Значение находится в распоряжении после ввода действия XSYR в элементе данных TELE.par1. В TELE.bedelem подается сигнал оповещения о наличии запрошенного элемента данных в используемом шаблоне или его отсутствии (0 -> элемент управления присутствует, -1 -> элемент отсутствует).


GRAFIK ( < Элемент управления > TXLOAD < Операнд[IN_ST_DE] > < Операнд[ST_DE] > )

Алгоритм действует только для элементов управления типа TEXTEDIT и TEXTEDITVEK и предназначен для загрузки файла. Для элементов управления типа TEXTEDITVEK в каждом элементе вектора загружается файл.

Параметры означают следующее:

1.) Субобъект или -1.
-1: Алгоритм относится ко всему элементу управления. n : Алгоритм относится к n-ому субобъекту элемента управления.

2.) Имя файла

3.) Режим Режим определяет продолжение обработки алгоритма.

"S"          : Продолжение обработки с MARKE, если файл не был загружен. "s"          : Продоление обработки с MARKE, если файл был загружен. sonst        : Продолжение обработки сразу после TXLOAD_алгоритма.


GRAFIK ( < Элемент управления > TXSAVE < Операнд[IN_ST_DE] > < Операнд[ST_DE] > )

Алгоритм действует только для элементов управления типа TEXTEDIT и TEXTEDITVEK и служит для сохранения в файл. Для элементов управления типа TEXTEDITVEK в каждом элементе вектора сохраняется файл.

Параметры означают следующее:

1.) Субобъект или -1.
-1: Алгоритм относится ко всему элементу управления. n : Алгоритм относится к n-ому субобъекту элемента управления.

2.) Имя файла (=>имя файла = TXLOAD-имя файла)

3.) Режим Режим определяет продолжение обработки алгоритма.

"S"          : Продолжение обработки с MARKE, если файл не был загружен. "s"          : Продоление обработки с MARKE, если файл был загружен. sonst        : Продолжение обработки сразу после TXSAVE_алгоритма.


GRAFIK ( < Элемент управления > TXCTRL < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > )

Алгоритм действует только для элементов управления типа TEXTEDIT и TEXTEDITVEK и служит для управления. Для элементов управления типа TEXTEDITVEK изменяется каждый элемент вектора.

Параметры означают следующее:

1.) Субобъект или -1.
-1: Алгоритм относится ко всему элементу управления. n : Алгоритм относится к n-ому субобъекту элемента управления.

2.) Информация о документе ("F" или "-" (соответственно, не "F")) Изменения отправляются в диалог и отображаются при вводе объекта "F" со следующим текстом: "<rows> <ranf> <rend> <ranz> <cols> <canf> <cend> <canz> <expd>" <rows> := Общее количество строк <ranf> := Первая видимая строка <rend> := Последняя видимая строка <ranz> := Количество видимых строк <cols> := Максимальная длина строк <canf> := Первый видимый столбец <cend> := Последний видимый столбец <cend> := Количество видимых столбцов <expd> := Максимальная длина строк с Tab-расширением

3.) Режим приращения/замещения (Inkremet-/Replace)("I" или "R" (соответственно, не "I"))

4.) Clear/позиция ("C" или "P" или "-" (соответственно ни "C", ни "P"))

"C" : Элемент управления удаляется "P" : Изменяется позиция отображения

5.) Первая отображенная строка ( для "P") "-1" = последняя строка

6.) Первый отображенный столбец ( для "P") "-1" = последний столбец


GRAFIK ( < Элемент управления > TXREAD < Операнд[IN_ST_DE] > < Операнд[DE] > )

Алгоритм действует только для элементов управления типа TEXTEDIT и TEXTEDITVEK и служит для запроса содержимого. Для элементов управления типа TEXTEDITVEK у каждого элемента вектора запрашивается его содержимое.

Параметры означают следующее:

1.) Субобъект или -1.
-1: Алгоритм относится ко всему элементу управления. n : Алгоритм относится к n-ому субобъекту элемента управления.

2.) Элемент данных (вектора) Содержимое сохраняется в элементе данных (вектора) построчно (при этом удаляется '\n'). Слишком длинные строки разделяются на две. Лишние строки отбрасываются. Не используемые элементы вектора удаляются. В элементе данных после элемента данных(вектора) сохраняется также количество прочитанных строк.

GRAFIK ( < Элемент управления > TXAPPD < Операнд[IN_ST_DE] > < Операнд[DE] > )

Алгоритм действует только для элементов управления типа TEXTEDIT и TEXTEDITVEK и служит для вывода содержимого текста. Для элементов управления типа TEXTEDITVEK в каждом элементе вектора выводится содержимое.

Параметры имеют следующее значение:

1.) Субобъект или -1.
-1: Алгоритм относится ко всему элементу управления. n : Алгоритм относится к n-ому субобъекту элемента управления.

2.) Элемент данных(вектора) Содержимое элемента вектора выводится построчно (при этом добавляется '\n' ). В элементе данных за элементом данных(вектора) стоит количество необходимых для вывода строк.



1.11.14.4.2.6  Алгоритмы последовательных шагов

Порядок задания шагов принципиально определяет их последовательность обработки. После завершения последнего шага фаза диалога также завершается, и пользователь, сформировавший задание получает телеграмму завершения фазы со следующим синтаксисом:

PEND < Имя диалога > < Имя фазы >

Существует несколько алгоритмов для определения следующего шага при отклонении от порядка задания шагов:

< Абсолютный шаг >:

Алгоритм устанавливает следующий шаг в качестве текущего и имеет следующий синтаксис:

FOLGESCHRITT < Имя шага >

< Имя шага >: Идентификатор блока шага (который должен быть в наличии), однозначный внутри фазы диалога, макс. 16 символов.

Алгоритм последовательных шагов помечает шаг в качестве следующего для выполнения, если текущий шаг завершен. Алгоритм с различными шагами может встречаться в фрагменте задания неоднократно. Принципиально фрагмент задания обрабатывается полностью. Алгоритмы последовательных шагов не могут быть использованы в глобальных макросах.


< Приращение шага >:

SCHRITTP

Предварительная пометка следующего(согласно порядку объявления) шага в фазе диалога в качестве следующего предназначенного для выполнения, если текущий шаг завершен. Если текущий шаг является последним объявленным шагом, то алгоритм действует таким образом, что альнейшие(предназначенные для выполнения) шаги отсутствуют и при завершении текущего шага фаза диалога также завершается. Пользователь, сформировавший задание, получает телеграмму завершения фазы.


< Декремент шага >:

SCHRITTM

Предварительная пометка предыдущего(согласно порядку объявления) шага в фазе диалога в качестве следующего предназначенного для выполнения, если текущий шаг завершен. Если текущий шаг является первым объявленным шагом, то алгоритм действует таким образом, что дальнейшие(предназначенные для выполнения) шаги отсутствуют и при завершении текущего шага фаза диалога также завершается. Пользователь, сформировавший задание, получает телеграмму завершения фазы.

< Определение шага >: SCHRITTE < Операнд[ST_DE_DS] >

Содержимое элемента данных или строки понимается как целое число и обрабатывается в блоке управления шагами в качестве альтернативного критерия выбора. Там для каждого шага и каждой альтернативы задан следующий шаг. Обработка фрагмента шага соответствует обработке в FOLGESCHRITT.

Для случая набора данных в качестве критерия выбора альтернативы берется текущий номер, начиная с 1, того элемента, который является первым элементом в порядке объявления, чей статус не равен 0. Если статус набора данных равен 0, то критерий выбора альтернативы акже равен 0.

Если никакой последующий шаг не может быть определен, то при завершении текущего шага завершается и сама фаза диалога. Пользователь, сформировавший задание, получает телеграмму завершения фазы.


1.11.14.4.2.7  Циклический алгоритм

Циклический алгоритм выполняет макрос повторно до тех пор, пока индекс находится в указанном интервале. Алгоритм имеет следующий синтаксис:

< Циклический алгоритм >: SCHLEIFE < Операнд[IN] > < Операнд[IN_ST_DE] > < Операнд[IN_ST_DE] > < Макрос >


Параметры в вышеуказанной последовательности означают следующее:

1.) Индекс цикла.
2.) Начало интервала.
3.) Конец интервала.
4.) Тело цикла.

В начале цикла индекс устанавливается в начало интервала. Если индекс находится в интервале (т.е. области между началом и концом интервала), макрос выполняется. Индекс может быть изменен в макросе вручную, после каждого выполнения цикла он увеличивается на единицу.

1.11.14.4.2.8  Алгоритм резервирования монитора

Следующий алгоритм служит для резервирования монитора для диалога, являющегося общим для этого монитора, который привязывает курсор к этому диалогу:

< Резервирование монитора >: MONGLODIAEIN

Каждая следующая попытка зарезервировать монитор для диалога приводит к состоянию ожидания запрашиваемого диалога, из которого он освобождается его же пользователем ("владельцем") только при его разрешении.

Следующий алгоритм служит для выхода из эксклюзивного режима использования монитора:

< Освобождение монитора >: MONGLODIAAUS

Если монитор не зарезервирован диалогом, то алгоритм не действует, в противном случае резервирование отменяется и другой диалог может зарезервировать монитор.

1.11.14.4.2.9  Вызов макроса

Локальный или глобальный макрос может быть вызван с помощью следующего алгоритма:

< Вызов макроса >: < Имя макроса >

< Имя макроса >: Имя вызываемого макроса. Имя должно быть объявлено в секции макросов алгоритмов или в соответствующем фрагменте.


1.11.14.4.2.10  Алгоритмы фрагментов

Если обработка фрагмента завершается, то в качестве следующего обрабатывается тот фрагмент, который был предустановлен либо автоматически (т.е. по умолчанию), либо вручную с помощью следующих алгоритмов фрагментов. Если фрагмент не задан по умолчанию, то считается, что завершен.

< Алгоритмы фрагментов >: < Тип шага_фрагмент_по умолчанию >           или < Прерывание шага_фрагмент_по умолчанию>     или < Завершение шага_фрагмент_по умолчанию >    или < Повтор шага_фрагмент_по умолчанию >        или < Ошибка шага_определение фрагмента>         или < Достоверность шага_определение фрагмента > или < Алгоритм прыжка/скачка >

< Тип шага_фрагмент_по умолчанию >: SCHRITTSTART

Выполняется предустановка "Тип шага_фрагмент".


< Прерывание шага_фрагмент_по умолчанию >: SCHRITTABBRUCH

Выполняется предустановка "Прерывание шага_фрагмент".


< Завершение шага_фрагмент_по умолчанию >: SCHRITTENDE

Выполняется предустановка "Завершение шага_фрагмент".

< Повтор шага_фрагмент_по умолчанию >: SCHRITTCONT

Выполняется предустановка "Повтор шага_фрагмент".

< Ошибка шага_определение фрагмента >: SCHRITTFEHLER

SCHRITTFEHLER - алгоритм со скрытым параметром. Здесь количество возникших ошибок в шаге берется в качестве основного параметра для решения: либо предустановить "Повтор шага_фрагмент" в случае ошибки, либо "Конец шага_фрагмент" при отсутствии ошибок. Количество возникших ошибок берется из списка FTEXTE.


< Достоверность шага_определение фрагмента >: SCHRITTPLAUS < Операнд[ST] > < Операнд[DE_DS] >

SCHRITTPLAUS планирует фрагмент на основе проверки статуса какого-то набора или элемента данных, созданного в ходе достоверизации. Немедленного ветветвления на запланированный фрагмент не производится.

Параметры в вышеуказанной последовательности означают следующее:
1.) Задание фрагмента, который должен быть запланирован, для случая достоверности или недостоверности. Параметром является строка, состоящая из 2х символов. Первый символ указывает фрагмент, который планируется в достоверном случае, а второй символ определяет алгоритм для недостоверного случая.

Допустимы следующие символы :

S        -> Фрагмент запуска шага W        -> Фрагмент повтора шага E        -> Фрагмент завершения шага A        -> Фрагмент прерывания шага D        -> Фрагмент диалога шага
-        -> изменение существующего планирования отсутствует

Пример : "EW" :  достоверно    -> Фрагмент завершения шага не достоверно -> Фрагмент повтора шага

"-W" :  достоверно    -> Изменение существующего планирования отсутствует не достоверно -> Фрагмент повтора шага

2.) Набор или элемент данных, статус которого обрабатывается с целью определения достоверности или недостоверности и согласно п. 1.) планирования настроек фрагментов.

Алгоритмы фрагментов, которые выбирают определенный фрагмент без условий, являются целесообразными в сочетании с условными алгоритмами или в особых случаях.

< Алгоритм прыжка/скачка >: SPRUNG

Планирование фрагмента последовательности является эффективным (действенным), если фрагмент последовательности отличается от текущего фрагмента, в противном случае алгоритм игнорируется, а планирование остается.


1.11.14.4.2.11  Алгоритмы окончания(завершения) фазы

Этот алгоритм помечает конец фазы диалога. Целесообразным было бы, если бы этот алгоритм был бы последним алгоритмом в "Тип шага_фрагмент" для последнего шага каждой фазы диалога. Алгоритм имеет следующий синтаксис:

PHASEND Сокращение(аббревиатура) команды для 'Конец фазы'.

Пользователь, сформировавший задание, получает телеграмму окончания фазы со следующим синтаксисом:

PEND < Имя диалога > < Имя фазы >

1.11.14.4.2.12  Алгоритм запуска диалога

Этот алгоритм запускает параллельный диалог для того же самого пользователя.

Алгоритм имеет следующий синтаксис:

DIASTART < Операнд[ST_DE] > < Операнд[ST_DE] > < Операнд[ST_DE] >

DIASTART: Сокращение(аббревиатура) команды для 'Запуск диалога'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Имя, под которым должен выполняться запускаемый диалог Внимание: При конфликте имени с именами уже имеющихся диалогов диалог не запускается!
2.) Имя файла управления диалогом ( см. раздел 1. 11 ).
3.) Строка параметров ( см. раздел 1. 3 ).

При выполнении алгоритма генерируется случай ввода действия для выполняемого диалога. Он имеет следующую форму:

DSPO      при успешном запуске DSNE      в случае неудачи

Передается следующая строка параметров:

Имя диалога Статус  (0 = ok , в противном случае - статус ошибки)


1.11.14.4.2.13  Алгоритм запуска запланированного диалога

Этот алгоритм запускает ранее запланированный пользователем параллельный диалог для того же самого пользователя.

Алгоритм имеет следующий синтаксис:

DIAPLST < Операнд[ST_DE] > < Операнд[ST_DE] >

DIAPLST: Сокращение(аббревиатура) команды для 'Запуск запланированного диалога'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Имя, под которым запланирован новый запускаемый диалог.
2.) Строка параметров ( см. раздел 1. 3 ).

При выполнении алгоритма генерируется случай ввода действия для выполняемого диалога. Он имеет следующую форму:

DSPO      при успешном запуске DSNE      в случае неудачи

Передается следующая строка параметров:

Имя диалога Статус  (0 = ok , в противном случае - статус ошибки)

1.11.14.4.2.14  Алгоритм завершения диалога

Следующий алгоритм завершает диалог без завершения зависимых от него диалогов или диалога, от которого он сам зависит.

Алгоритм имеет следующий синтаксис:

DIAENDE < Операнд[ST_DE] >

DIAENDE: Сокращение(аббревиатура) команды для 'Завершение диалога'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Имя диалога, который требуется завершить. Может быть завершен собственный или любой другой диалог.


При прерывание запущенного пользователем диалога прерывание квитируется с помощью ABDI. (см. 1. 5) При прерывание запущенного с помощью DIASTART диалога генерируется случай ввода действия для вызванного диалога. Он имеет следующую форму:

DAPO

Передается следующая строка параметров:

Имя диалога Статус  (0 = ok , в противном случае - статус ошибки)


Следующий алгоритм завершает семейство диалогов из основного диалога и всех зависимых диалогов. При этом несущественно, приведено ли имя основного диалога или субдиалога в качестве параметра.

Алгоритм имеет следующий синтаксис:

DIAABBR < Операнд[ST_DE] >

DIAABBR: Сокращение(аббревиатура) команды для 'Прерывание диалога'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Имя прерываемого диалога. Может быть прерван собственный или любой другой диалог.

Прерывание диалогов квитируется с помощью ABDI. (см. 1. 5)

1.11.14.4.2.15  Алгоритм импорта данных диалога

Этот алгоритм импортирует содержимое набора данных какого-либо диалога и копирует его в набор данных собственного диалога. При этом содержимое элементов данных исходного набора данных (т.е. источника) преобразуется в тип соответствующего элемента данных конечного набора данных (т.е. целевого). Копируется максимум столько элементов данных, сколько задано минимальным количеством элементов данных обоих наборов данных.


Алгоритм имеет следующий синтаксис:

DIAIMPORT < Операнд[ST_DE] > < Операнд[ST_DE] > < Операнд[DS] >

DIAIMPORT: Сокращение(аббревиатура) команды для 'Импорт данных диалога'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Имя диалога, в котором находится исходный набор данных (т.е. источник) Это может быть собственный или любой другой диалог.
2.) Имя исходного набора данных (источника).
3.) Имя конечного набора данных (целевого).


Имя исходного набора данных (источника) не проверяется для времени компилляции. Если в исходном диалоге (источника) отсутствует набор данных с таким именем, то алгоритм не выполняется.

1.11.14.4.2.16  Алгоритм экспорта данных диалога

Этот алгоритм экспортирует содержимое набора данных собственного диалога и копирует его в набор данных какого-то другого диалога. При этом содержимое элементов данных исходного набора данных (т.е. источника) преобразуется в тип соответствующего элемента данных конечного набора данных (т.е. целевого). Копируется максимум столько элементов данных, сколько задано минимальным количеством элементов данных обоих наборов данных.

Алгоритм имеет следующий синтаксис:

DIAEXPORT < Операнд[ST_DE] > < Операнд[ST_DE] > < Операнд[DS] >

DIAEXPORT: Сокращение(аббревиатура) команды для 'Экспорт данных диалога'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Имя диалога, в котором находится конечный набор данных (т.е. целевой) Это может быть собственный или любой другой диалог.
2.) Имя конечного набора данных (целевого).
3.) Имя исходного набора данных (источника).



Имя конечного набора данных (целевого) не проверяется для времени компилляции. Если в конечном диалоге (целевом) отсутствует набор данных с таким именем, то алгоритм не выполняется.

1.11.14.4.2.17  Алгоритмы элементов управления

Алгоритм наследования элементов управления необходим в тех случаях, когда диалог использует элементы управления, которые объявлены в окне, которое он сам не открыл, и причем он использует эти элементы управления вместе (даже если и по очереди) с диалогом, который открыл окно.

Этот алгоритм импортирует все динамические параметры элемента управления какого-то другого диалога и копирует их в собственный элемент управления того же типа или передает динамические данные собственного элемента управления элементу управления какого-то другого диалога.

Алгоритм имеет следующий синтаксис:

BEDVERERB < Элемент управления > < Операнд[ST_DE] > < Операнд[ST_DE] > < Операнд[ST_DE] >

BEDVERERB: Сокращение(аббревиатура) команды для 'Наследование элемента управления'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Опция алгоритма. "L"          : импортировать данные в собственный элемент управления "S" или все остальное: передать данные стороннему (внешнему) элементу управления. Сначала должна быть обязательно выполнена опция "L" для импорта нормальных данных в первый раз, так как в противном случае обратно передаются лишь инициализированные данные.
2.) Имя диалога, в котором находится импортируемый элемент управления. Собственный диалог таковым быть не может.
3.) Имя объявления импортируемого элемента управления. Типы обоих элементов управления должны совпадать.


Алгоритм экспорт элемента управления необходим в том случае, если диалогу "Элементы управления" не требуется с его помощью открытое вручную окно, а он разрешает другому диалогу использовать его данные в эксклюзивном режиме. Алгоритм действует таким образом, что все введенные данные в этих элементах управления автоматически передаются другому диалогу. Для возможности использования элементов управления в другом диалоге ему должен быть передан номер окна, в котором находится элемент управления. Диалог должен записать номер окна в соответствующем управлении окном.

< Имя окна > = Номер окна

Если один и тот же элемент управления используют несколько диалогов, в которые были экспортированы элементы управления, то диалог, являющийся первым в логическом порядке вызова, получает входные данные.

Алгоритм имеет следующий синтакис:

BEDEXP < Операнд[ST_DE] > < Операнд[ST_DE] >

BEDEXP: Сокращение(аббревиатура) команды для 'Экспорт элемента управления'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Имя того диалога, который должен или больше не должен получать данные, в зависимости от параметра 2. Если это имя собственного диалога, то алгоритм не оказывает никакого действия.
2.) Строка длиной макс. 16 символов. "-" : Возврат права доступа к элементу управления. При этом обратно принимается также возможно установленный при назначении префикс имени элемента управления. ""  или пусто     : Назначение прав доступа к элементам управления, указанным в диалоге. Какая-либо строка : Назначение прав доступа к элементам управления, указанным в диалоге. Шаблонные имена элементов управления дополняются предпозицией строки.

Пример : Пусть в диалоге UPS объявлены следующие элементы управления:

SYMBOL         CLOSE     DEBW clt TEXTOUT        WINNR     DEBW wnr TEXTOUT        WINNAME   DEBW wna

С помощью алгоритма

BEDEXP "UPS" "men.t1."

все входные данные элементов управления

men.t1.CLOSE men.t1.WINNR men.t1.WINNAME

передаются диалогу UPS. В UPS все графические алгоритмы равным образом дополняются префиксом "men.t1.".


С помощью алгоритма

BEDEXP "UPS" "-"

действие алгоритма BEDEXP "UPS" "men.t1." снова отменяется.

Следует учитывать, что дополненные имена не могут иметь более 16 символов!!! Многократное назначение прав доступа для одного и того же алгоритма является допустимым. Действительной же является последняя настройка алгоритма.


Алгоритм окна пользователя является необходимым при желании обработки всех вводов(Inputs) элементов управления какого-либо окна в диалоге не с помощью диалогового инструментария, а с помощью пользователя.

Алгоритм имеет следующий синтаксис:

USERWIN < Имя окна > < Операнд[IN_ST_DE] >

USERWIN: Сокращение(аббревиатура) команды для 'Окно пользователя'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Имя того окна, вводы(Inputs) элемента управления которого должны быть перенаправлены пользователю или снова обработаны диалоговом инструментарием, в зависимости от параметра 2.
2.) Статус окна.
0 : Все вводы(Inputs) элементов управления попадают в диалоговый инструментарий.
1 : Вводы(Inputs) данных путем выбора курсора (Случаи_ввода объекта со статусом C) передаются пользователю, вводы(Inputs) содержимого данных(Случаи_ввода объекта со статусом I) попадают в диалоговый инструментарий.
2 : Вводы(Inputs) содержимого данных отправляются пользователю, вводы(Inputs) данных путем выбора курсора попадают в диалоговый инструментарий.
3 : Пользователю передаются как вводы(Inputs) данных путем выбора курсора, так и вводы(Inputs) содержимого данных.
4 : Специальные кнопки передаются пользователю (например, средняя кнопка мыши).
5 : Специальные кнопки и вводы(Inputs) типа "Выбор альтернативы" передаются пользователю.
6 : Специальные кнопки и вводы(Inputs) содержимого передаются пользователю.
7 : Специальные кнопки, вводы(Inputs) типа "Выбор альтернативы" и вводы(Inputs) содержимого передаются пользователю. Другие значения объединяются с маской 0x07 с помощью операции логического "И" и представляются таким образом значениями 0-7.


"Алгоритм_имя элемента управления" определяет из номера элемента управления имя относящегося к нему элемента управления (имя шаблона), включая возможное дополнение имени префиксом.

"Алгоритм_имя элемента управления" имеет следующий синтаксис:

BEDNAME < Операнд[IN_ST_DE] > < Операнд[DE] >

BEDNAME: Сокращение(аббревиатура) команды для 'Алгоритм_имя элемента управления'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Номер элемента управления Начинающаяся с нуля относительная нумерация всех заданных в диалоге элементов управления. Здесь должен быть задан номер текущего элемента управления (например, из TELE.bedelm).

2.) Целевой буфер, в котором должен быть сохранен элемент управления.


С помощью алгоритма пользователя диалога диалогу может быть назначен другой пользователь диалога. Все без исключения задания, предназначенные для внешнего пользователя, отправляются новому пользователю диалога.

Алгоритм имеет следующий синтаксис:

DIAUSER < Операнд[ST_DE] > < Операнд[IN_ST_DE] >

DIAUSER: Сокращение(аббревиатура) команды для 'Алгоритм пользователя диалога'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Имя диалога, для которого должен быть переключен (т.е. изменен) пользователь.
2.) Номер или имя (например, ЦДД) внешнего пользователя, который после переключения должен получить все задания диалога. Номер или имя должны быть в списке внешних пользователей диалогового инструментария DIAT. Если они там отсутствуют, то задание для пользователя диалога отклоняется.

Внимание ! Диалоги, запущенные с помощью DIASTART, после переключения на другого пользователя диалога ведут в отношении квитирования себя иначе:

Прерывание диалога с помощью :  Работа семейства диалогов не завершается, пользователь диалога не DIAABBR или ABDI                получает квитирования.

DIASTART, DIAENDE            :  Основной диалог не получает DSPO-, DSNE- или DAPO-квитирований.

1.11.14.4.2.18  Алгоритм_HALT

Этот алгоритм останавливает обработку диалога.

Он имеет следующий синтаксис:

HALT

HALT: Сокращение(аббревиатура) команды для 'ОСТАНОВИТЬ_ОБРАБОТКУ'.

Работу с диалогом можно вновь продолжить с помощью отладчика диалога.


1.11.14.4.2.19  Алгоритм приостановки(паузы)

Этот алгоритм прерывает обработку диалога на указанное время.

Он имеет следующий синтаксис:

PAUSE < Операнд[IN_ST_DE] >

PAUSE: Сокращение(аббревиатура) команды для 'Пауза в обработке'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Время ожидания в секундах.

1.11.14.4.2.20  Алгоритм звука

При нажатии < CNTRL G > этот алгоритм подает звуковой сигнал.

Имеет следующий синтаксис:

TON

TON: Сокращение(аббревиатура) команды для 'Вывод/подача звукового сигнала'.

Длительность и звук сигнала зависят от используемой системы.

1.11.14.4.2.21	Алгоритмы событий

Алгоритмы событий служат для генерации событий согласно Geatronic SN, причем эти события относятся к определенным, четко зафиксированным процессным переменным системы. Адреса этих заданных процессных переменных хранятся в модели данных DIATа.

Отклики на эти события должны быть запараметрированы в обработке событий под соответствующими адресами соответствущих процессных переменных.

Общий алгоритм события имеет следующи синтаксис:

EREIGNIS TEXT < Операнд[ST_DE] >


EREIGNIS TEXT: Сокращение(аббревиатура) команды для 'Спорадически вызвать текст события'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Произвольный текст события, который должен быть выведен спорадически в списке событий.

В произвольном тексте в последовательности управляющих команд реализован механизм замены/замещения текста. Формальные параметры вида [<Номер параметра>], встречающиеся в тексте события, заменяются/замещаются актуальными(текущими) параметрами.

Заданы следующие формальные параметры:

[0]  -> Имя диалога последовательности управляюзих команд (BDFnnn.flg)

[1]  -> Идентификатор(имя) последовательности управлящих команд

[2]  -> Режим моделирования

Любой другой формальный параметр [x] приводит к тому, что алгоритм события не выполняется.

Формальные параметры за пределами последовательности управляющих команд остаются в тексте без изменений.

Пример внутри последовательности управляющих команд PUMPENPROGRAMM:

EREIGNIS TEXT "BEDIENFOLGE [1] GESTARTET"  ->

EREIGNIS TEXT "BEDIENFOLGE PUMPENPROGRAMM GESTARTET"


Алгоритм события HALT служит для задания текста события, который выводится в списке событий в случае, когда последовательность управляющих команд останавливается с помощью алгоритма HALT. Алгоритм имеет следующий синтаксис:

EREIGNIS HALT < Операнд[ST_DE] >

EREIGNIS HALT: Сокращение(аббревиатура) команды для 'Установить событие HALT'.

Параметр означает следующее :

1.) Текст события, который выводится при выполнении алгоритма HALT. Действительным текстом события всегда является последний текст, заданный с помощью алгоритма события HALT. Если никакой текст события не был задан с помощью алгоритма события HALT, то событие HALT не вызывается. В тексте события могут использоваться формальные параметры, описанные в основном алгоритме события. Путем задания пустого текста события вывод событий HALT может быть отключен.


Алгоритм события WEITER служит для задания текста события, который выводится в списке событий в случае, когда остановленная последовательность продолжает выполняться с помощью алгоритма WEITER. Алгоритм имеет следующий синтаксис:

EREIGNIS WEITER < Операнд[ST_DE] >

EREIGNIS WEITER: Сокращение(аббревиатура) команды для 'Установить событие WEITER'.

Параметр означает следующее:

1.) Текст события, который выводится при выполнении алгоритма WEITER. Действительным текстом события всегда является последний текст, заданный с помощью алгоритма события WEITER. Если никакой текст события не был задан с помощью алгоритма события WEITER, то событие WEITER не вызывается. В тексте события могут использоваться формальные параметры, описанные в основном алгоритме события. Путем задания пустого текста события вывод событий WEITER может быть отключен.


1.11.14.4.2.22	Алгоритмы даты и времени

Для обработки даты и времени имеются следующие алгоритмы.

Алгоритм времени определяет текущее время в секундах на основе 1.1.1970-0:0:0 GMT.

Алгоритм времени имеет следующий синтаксис:

UHRZEIT < Операнд[DE] >

UHRZEIT: Сокращение(аббревиатура) команды для 'Определить текущее время'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Целевой буфер для текущего времени (double).


Алгоритм дня определяет текущий учётный день на основе 1.1.1970.

Алгоритм дня имеет следующий синтаксис:

TAG < Операнд[DE] >

TAG: Сокращение(аббревиатура) команды для 'Определить текущий учётный день'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Целевой буфер для текущего учётного дня.


Алгоритм_строка_во_время_дату преобразует строку времени, которая была принята при достоверизации DATIM, во внутреннее представление времени в секундах, начиная с 1.1.1970. Преимуществом по сравнению с STR_ZEIT является не установленная последовательность даты и времени (см. DATIM)


Алгоритм_строка_во_время_дату имеет следующий синтаксис:

STR_DATIM < Операнд[ST_DE] > < Операнд[DE] >

Параметры в вышеуказанной последовательности означают следующее:

1.) Строка времени/даты, которая должна быть преобразована во внутреннее представление времени. Примеры: см. DATIM

2.) Целевой буфер для внутреннего представления времени (double).

Алгоритм_строка_во_время преобразует строку времени или строку времени/даты в секунды во внутреннем представлении, начиная с 1.1.1970-0:0:0 GMT.


Алгоритм_секунды_в_строку имеет следующий синтаксис:

SEC_STR < Операнд[ST_DE] > < Операнд[DE] > < Операнд[ST_DE] >

SEC_STR: Сокращение(аббревиатура) команды для 'Преобразовать секунды (начиная с 01.01.1970) в в читаемую и произвольно определяемую строку'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Преобразуемое время в секундах, начиная с 01.01.1970 (double)

2.) Целевой буфер, в котором будет сохранен результат преобразования

3.) Формат времени (макс. 64 символа). Могут использоваться следующие форматы: # %  словесный % # %a сокращенное имя дня недели локали (пн..вс) # %A полное имя дня недели, переменная длина (понедельник..воскресенье) # %b сокращенное имя месяца локали (янв..дек) # %B полное имя месяца, переменная длина (январь..декабрь) # %d месяц дня (1..31) # %D дата (%02d.%02m.%02y) # %H час (0..23) # %m месяц (1..12) # %M минута (0..59) # %S секунда (0..60); 60 требуется для возможных секунд переключения (*) # %T время, 24 часа (%02H%-2z:%02M:%02S) # %y две последние цифры года (0..99) # %Y год (1970...) # %z отображать два часа для дня переключения # %Z выводить флаг времени (UHR_F)


Алгоритм_строка_во_время преобразует строку времени или времени/даты в секунды во внутреннем представлении, начиная с 1.1.1970-0:0:0 GMT.

Алгоритм_строка_во_время имеет следующий синтаксис:

STR_ZEIT < Операнд[ST_DE] > < Операнд[DE] >

STR_ZEIT: Сокращение(аббревиатура) команды для 'преобразовать строку во внутренне представление'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Строка времени/даты, которая должна быть преобразована во внутреннее представление. Строка времени/даты ожидается в формате ЧЧ:ММ:СС ДД.ММ.ГГГГ или ЧЧ:ММ:СС ДД.ММ.ГГ. Преобразование производится для указанного в строке даты дня или для текущего дня.

Данные в строке времени могут быть частично отброшенны справа налево, включая ":". Значение для отсутствующих данных, соответственно, устанавливается в 0. Указание часа (ЧЧ) является строго необходимым.

Данные в строке даты могут быть полностью или частично отброшенны справа налево, включая '.'. Для отсутствующих данных устанавливается текущее значение.

Если строка времени/даты не соответствует вышеуказанному формату, то данный алгоритм не учитывается и обработка диалога продолжается.

Примеры:

10:25:33 5.7.92    -> 10:25:33 5.7.1992
11:13:12 6.2.1994  -> 11:13:12 6.2.1994
14:2 5.4           -> 14:02:00 5.4.<тек. год>
7:10:30 8          -> 07:10:30 8.<тек. мес.>.<тек. год>
8                  -> 08:00:00 <тек. день>.<тек. месяц>.<тек. год>
9:                 -> Ошибка: отсутствует минута
11:22 7.           -> Ошибка: отсутствует месяц
14: 12.4           -> Ошибка: отсутствует день (14:12:00 ?.04.<тек. год>)

2.) Целевой буфер для внутреннего представления времени (double).


Алгоритм_строка_в_день преобразует строку даты в учётный день на основе 1.1.1970.

Алгоритм_строка_в_день имеет следующий синтаксис:

STR_TAG < Операнд[ST_DE] > < Операнд[DE] >

STR_TAG: Сокращение(аббревиатура) команды для 'Преобразовать строку в учётный день'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Строка даты, которая должна быть преобразована в учётный день. Строка даты ожидается в формате в формате ДД.ММ.ГГГГ или ДД.ММ.ГГ.

Данные в строке даты могут быть частично отброшены справа налево, включая '.' . Значение для отсутствующих данных, соответственно, устанавливается в 0. Указание дня (ЧЧ) является строго необходимым.

Если строка даты не соответствует вышеуказанному формату, то данный алгоритм не учитывается и обработка диалога продолжается.

Примеры:

5.7.92    -> 5.7.1992
6.2.1994  -> 6.2.1994
5.4       -> 5.4.<тек. год>
8         -> 8.<тек. месяц>.<тек. год>
7.        -> Ошибка: месяц отсутствует .4        -> Ошбика: день отсутствует

2.) Целевой буфер для учётного дня.

1.11.14.4.2.23	Алгоритм планирования

Алгоритм планирования прерывает обработку диалога по достижении времени планирования.

Алгоритм планирования имеет следующий синтаксис:

EINPLANUNG < Операнд[ST_DE] > < Операнд[IN_ST_DE] > < Операнд[ST_DE] >

EINPLANUNG: Сокращение(аббревиатура) команды для 'Алгоритм планирования'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Время планирования Время, начиная с которого должен быть продолжен следующий алгоритм. Время планирования ожидается в формате ЧЧ:ММ:СС. Если время планирования не соответствует этому формату, то алгоритм не учитывается и обработка диалога продолжается.

2.) Допустимый сдвиг в секундах Если текущее время по достижении алгоритма планирования меньше времени планирования (тек. время < время планирования), то ожидается наступление времени планирования и обработка продолжается сразу после алгоритма планирования. Допустимый сдвиг в данном случае не используется. Если текущее время по достижении алгоритма планирования больше или равно времени планирования, но находится в пределах допустимого сдвига в секундах (время планирования =< тек. время <= время планирования + допустимый сдвиг), то обработка продолжается сразу после алгоритма планирования. Режим в данном случае не используется. Если текущее время по достижении алгоритма планирования больше времени планирования и выходит за пределы допустимого сдвига в секундах (тек. время > время планирования + допустимый сдвиг), то режим определяет продолжение обработки.

3.) Режим "S"           : продолжение обработки, начиная с MARKE (автоматический алгоритм_перехода_к_метке) "" или все остальное : продолжение обработки сразу после алгоритма планирования

1.11.14.4.2.24	Алгоритм сдвига планирования по времени(отсрочки)

Алгоритм сдвига планирования по времени(отсрочки) служит для сдвига времени планирования всех следующих выполняемых алгоритмов планирования на заданное по умолчанию время. Алгоритмы сдвига планирования по времени взаимно перезаписывают друг друга.

Алгоритм сдвига планирования по времени имеет следующий синтаксис:

EINPLANVER < Операнд[ST_DE] >

EINPLANVER: Сокращение(аббревиатура) команды для 'Сдвинуть время планирования'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Продолжительность сдвига Продолжительность сдвига указывает, на сколько должно быть сдвинуто время планирования всех последующих выполняемых алгоритмов планирования. Продолжительность сдвига ожидается в формате ЧЧ:ММ:СС. Если продолжительность сдвига не соответствует вышеуказанному формату, то алгоритм не учитывается и все времена планирований сохраняются прежними. Продолжительность времени сдвига может быть +-23:59:59.

1.11.14.4.2.25	Алгоритм перехода к метке

Алгоритм_перехода_к_метке "перепрыгивает" через все последующие алгоритмы в текущей иерархии (макрос, случай, фрагмент) к первому помеченному с помощью MARKE алгоритму. Если метка MARKE отсутствует, то "перепрыгивается" макс. через все алгоритмы до конца текущей иерархии алгоритмов. После этого алгоритм_перехода_к_метке теряет свою силу.

Алгоритм_перехода_к_метке имеет следующий синтаксис:

SPMARKE

SPMARKE: Сокращение(аббревиатура) команды для 'Переход к MARKE'.

1.11.14.4.2.26	Алгоритм метки

Алгоритм_метки помечает алгоритм для продолжения обработки после алгоритма_перехода_к_метке или алгоритма планирования с автоматическим переходом к MARKE.

Алгоритм_метки имеет следующий синтаксис:

MARKE

MARKE: Сокращение(аббревиатура) команды для 'Метка перед алгоритмом'.

1.11.14.4.2.27	Алгоритмы DAS-запроса

Следующие алгоритмы предназначены для обращения к подсистеме оценки данных (DAS):


DASANF IDFNAM < Операнд[ST_DE] > < Операнд[DE] > < Операнд[ST_DE] >

DASANF: Сокращение(аббревиатура) команды для 'DAS-запрос'.

IDFNAM: Запрос одного из четырех имен процессной переменной с идентификатором ПП (источник,индекс).

Параметры в вышеуказанной последовательности означают следующее:

1.) Идентификатор ПП в формате "< Тип > < Источник >,< Формат >".

< Тип >: Тип запрашиваемого имени. NAM  иерархическое имя LNG  технологическое имя KRZ  краткое имя ALI  псевдоним EXT  внешнее имя REF  имя ссылки

2.) Элемент данных, в котором сохранено имя в виде  < Имя_0 >.< Имя_1 >...< Имя_n >.

3.) Режим Режим определяет продолжение обработки алгоритма. "S"          : Продолжение обработки, начиная с MARKE, если никакие данные не были получены. "s"          : Продолжение обработки, начиная с MARKE, если данные были получены sonst        : Продолжение обработки сразу после алгоритма_DAS_запроса.


DASANF IDFWRT < Операнд[ST_DE] > < Операнд[IN_DE] > < Операнд[ST_DE] >

IDFWRT: Запрос текущего значения ПП с идентификатором ПП (источник, индекс).

Параметры в вышеуказанной последовательности означают следующее:

1.) Идентификатор ПП в формате "< Источник >,< Индекс >".

2.) Элемент данных или индекс, в котором записано текущее значение ПП.

3.) Режим (см.выше)


DASANF IDFSTA < Операнд[ST_DE] > < Операнд[IN_DE] > < Операнд[ST_DE] >

IDFSTA: Запрос текущего статуса ПП с идентификатором ПП (источник, индекс).

Параметры в вышеуказанной последовательности означают следующее:

1.) Идентификатор ПП в формате "< Источник >,< Индекс >".

2.) Элемент данных или индекс, в котором записан текущий статус ПП.

3.) Режим (см.выше)


DASANF NAMIDF < Операнд[ST_DE] > < Операнд[DE] > < Операнд[ST_DE] >

NAMIDF: Запрос идентификатора ПП с именем (< Имя_0 >.< Имя_1 >...< Имя_n >).

Параметры в вышеуказанной последовательности означают следующее:

1.) Имя ПП в формате (< Имя_0 >.< Имя_1 >...< Имя_n >).

2.) Элемент данных, в котором записан идентификатор в форме "< Источник >,< Индекс >".

3.) Режим (см.выше)


DASANF NAMWRT < Операнд[ST_DE] > < Операнд[IN_DE] > < Операнд[ST_DE] >

NAMWRT: Запрос текущего значения ПП с именем (< Имя_0 >.< Имя_1 >...< Имя_n >).

Параметры в вышеуказанной последовательности означают следующее:

1.) Имя ПП в формате (< Имя_0 >.< Имя_1 >...< Имя_n >).

2.) Элемент данных или индекс, в котором записан текущее значение ПП.

3.) Режим (см.выше)


DASANF NAMSTA < Operand[ST_DE] > < Operand[IN_DE] > < Operand[ST_DE] >

NAMSTA: Запрос текущего статуса ПП с именем (< Имя_0 >.< Имя_1 >...< Имя_n >).

Параметры в вышеуказанной последовательности означают следующее:

1.) Имя ПП в формате (< Имя_0 >.< Имя_1 >...< Имя_n >).

2.) Элемент данных или индекс, в котором записан текущий статус ПП.

3.) Режим (см.выше)


DASANF IDFHIR < Операнд[ST_DE] > < Операнд[DE] > < Операнд[ST_DE] >

DASANF: Сокращение(аббревиатура) команды для 'DAS-запрос'.

IDFHIR: Запрос иерархического адреса ПП с идентификатором ПП (источник, индекс).

Параметры в вышеуказанной последовательности означают следующее:

1.) Идентификатор ПП в формате "< Источник >,< Индекс >".

2.) Первый элемент вектора элементов данных, в котором должен быть записан иерархический адрес.

3.) Режим (см.выше)


DASANF IDFPAR < Операнд[ST_DE] > < Операнд[IN_DE] > < Операнд[ST_DE] >

IDFPAR: Запрос параметра с идентификатором ПП (источник, индекс).

Параметры в вышеуказанной последовательности означают следующее:

1.) Идентификатор ПП в формате "< Источник >,< Индекс > < Имя параметра >".

< Имя параметра >: Имя запрашиваемого параметра (например, "Единицы измерения").

2.) Элемент данных или индекс, в котором записан параметр.

3.) Режим (см.выше)


DASANF FREIDA < Операнд[ST_DE] > < Операнд[IN_DE] > < Операнд[ST_DE] >

FREIDA: Произвольный запрос DAS-данных. Ответы сохранены в наборе данных друг за другом. Пользователь данного алгоритма должен обратить внимание на то, что набор данных подходит для ответа. Для векторов первым записывается количество элементов. В конце набора данных или в индексе последующего переключения не происходит, и все остальные данные записываются в один и тот же элемент данных. Во избежание перезаписи после элементов данных, предназначенных для ответов, не должно следовать никаких других элементов данных. NOD's не перезаписывают текущий элемент данных и не устанавливают флаги FLAG и STA.

Параметры в вышеуказанной последовательности означают следующее:

1.) Произвольная строка алгоритма DAS. В DIAT никакая проверка синтаксиса строки алгоритма не выполняется.

2.) Начальный элемент данных или индекс, с которого записываются ответы.

3.) Режим (см.выше)


1.11.14.4.2.28  Алгоритм справки пользователя

Алгоритм справки пользователя служит для загрузки текста справки в текстовом окне (TXF). Кольцевой алгоритм функции текстового окна получает задание открыть текстовое окно для общей справки пользователя и отобразить текст справки.

Алгоритм справки пользователя имеет следующий синтаксис:

BEDHILFE < Операнд[ST_DE] > < Операнд[ST_DE] >

BEDHILFE: Сокращение(аббревиатура) команды для 'Справка пользователя'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Опция справки ("A" или "S" (все остальное в качестве "S"))

"A" : Открытие текстового окна с разделом, указанные во 2-м операнде. "S" : Внутреннее сохранение раздела. Открытие текстового окна производится только при нажатии на кнопку вызова справки.

2.) Класс текста справки и заголовок раздела желалемого текста справки в форме:

"< Класс текста справки >-< Заголовок раздела >"

Например:

"ABH-Монитор последовательности управляющих команд"

Возможны следующие случаи справки пользователя:

а) В файле управления диалогом справка пользователя не поддерживается -> При нажатии на кнопку вызова справки автоматически открывается текстовое окно с общей справкой. Пользователь должен самостоятельно выбрать желаемый текст справки.

б) В файле управления диалогом с помощью опции справки "S" задан заголовок раздела текста справки -> При нажатии на кнопку вызова справки автоматически открывается текстовое окно с заданным текстом справки.

в) В файле управления диалогом была объявлена кнопка вызова справки и связана со случаем диалога -> При нажатии на кнопку вызова справки сигнал передается диалогу. Текст справки должен выводиться вручную с помощью опции справки "A".

1.11.14.4.2.29  Алгоритм триггера

Этот алгоритм планирует случай диалога TRIG после некоторого указываемого времени. Это планирование снова удаляется следующим случаем диалога или следующим условием ожидания(например, данных и т.д.). Поэтому алгоритм должен выполняться в конце обработки случая и возможно обновляться при каждой обработке случая. По истечении времени вызывается случай диалога TRIG.

Алгоритм имеет следующий синтаксис:

TRIGGER < Операнд[IN_ST_DE] >

TRIGGER: Сокращение(аббревиатура) команды для 'Запланировать триггер'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Время ожидания в секундах.

1.11.14.4.3    Повтор шага_фрагмент

Если должен быть выполнен отсутствующий "Повтор шага_фрагмент", то предустанавливается выполнение фрагмента диалога ("Диалог_фрагмент"). Если "Повтор шага_фрагмент" есть в наличии, то предустанавливается выполнение фрагмента диалога (Диалог_фрагмент), а затем выполняются все алгоритмы "Повтор шага_фрагмент". Предустановки фрагмента могут быть изменены с помощью алгоритмов.


"Повтор шага_фрагмент" начинается с ключевого слова

ANWW{{{

и заканчивается ключевым словом

}}}ANWW    .


Между этими ключевыми словами находится перечень алгоритмов. Все алгоритмы, относящиеся к "Запуск шага_фрагмент", здесь также действительны.

"Повтор шага_фрагмент" не предустанавливается автоматически, как например, "Запуск шага_фрагмент" или "Диалог_фрагмент". Он может быть предустановлен только с помощью алгоритмов фрагмента. Обычно этот фрагмент из фрагмента диалога выбирается при ошибке диалога. После обработки этого фрагмента происходит автоматический возврат к "Диалог_фрагмент".

1.11.14.4.4    Прерывание шага_фрагмент

Если должен быть выполнен отсутствующий "Прерывание шага_фрагмент", то текущий шаг толкуется как завершенный. Если "Прерывание шага_фрагмент" есть в наличии, то выполняются все алгоритмы "Прерывание шага_фрагмент", а шаг толкуется как завершенный.

"Прерывание шага_фрагмент" начинается с ключевого слова

ANWA{{{

и заканчивается ключевым словом

}}}ANWA  .

Между этими ключевыми словами находится перечень алгоритмов. Все алгоритмы, относящиеся к "Запуск шага_фрагмент", здесь также действительны.

"Прерывание шага_фрагмент" не предустанавливается автоматически, как например, "Запуск шага_фрагмент" или "Диалог_фрагмент". Он может быть предустановлен только с помощью алгоритмов фрагмента. Обычно этот фрагмент из фрагмента диалога выбирается при таком вводе, который не должен приводить к нормальному завершению шага.



1.11.14.4.5    Завершение шага_фрагмент

Если должен быть выполнен отсутствующий "Завершение шага_фрагмент", то текущий шаг толкуется как завершенный. Если "Завершение шага-фрагмент" есть в наличии, то выполняются все алгоритмы "Завершение шага_фрагмент", а шаг толкуется как завершенный.

"Завершение шага_фрагмент" начинается с ключевого слова

ANWE{{{

и заканчивается ключевым словом

}}}ANWE  .

Между этими ключевыми словами находится перечень алгоритмов. Все алгоритмы, относящиеся в "Запуск шага_фрагмент", здесь также действительны.

"Завершение шага_фрагмент" автоматически предустанавливается, если должен быть запущен отсутствующий шаг диалога. Предустановка возможна также с помощью алгоритмов фрагмента. Обычно этот фрагмент должен быть выбран из фрагмента диалога при вводе данных(Input), приводящих к нормальному завершению шага.

1.11.14.4.6    Диалог_фрагмент

Если должен быть выполнен отсутствующий "Диалог_фрагмент", то предустанавливается выполнение "Завершение шага_фрагмент". Если "Диалог_фрагмент" есть в наличии, то предустанавливается выполнение "Диалог_фрагмент" и ожидается ввод(Input) данных.

Каждый случай запускается вводом действия или объекта. После распознавания случая входные данные находятся в распоряжении в автоматически объявленном наборе данных TELE.


TELE имеет следующие элементы данных:

status  %d hilf    %d subobj  %d vekobj  %d bedelm  %d par1    %32s par2    %32s par3    %32s par4    %32s par5    %32s wert    %132s

В TELE.status находится обозначение случая. В TELE.hilf находится индекс окна (при наличии). В TELE.subobj находится субобъект (при наличии). В TELE.vekobj находится индекс вектора (при наличии). В TELE.bedelm находится номер элемента управления (при наличии). В TELE.wert находится внесенная при вводе строка данных. В TELE.par1 до TELE.par5 находятся отдельные подстроки строки данных, которые отделены знаками пробела.

В "Диалог_фрагмент" задается соподчинение параметров ввода(Inputparameter) par.. объявленным наборам данных, а также приводится последовательность алгоритмов в зависимости от случая. Возможными являются все алгоритмы "Запуск шага_фрагмент". Не все алгоритмы являются целесообразными в данном фрагменте, так как они и так уже встречаются в одном из фрагментов "Запуск шага_фрагмент", "Повтор шага_фрагмент", "Прерывание шага_фрагмент", "Завершение шага_фрагмент". Дополнительно существуют алгоритмы, которые допустимы только в "Диалог_фрагмент".


"Диалог_фрагмент" начинается ключевым словом

DIALOG{{{

и завершается ключевым словом

}}}DIALOG .

Для каждого используемого в этом шаге случая задается соответствующая обработка. Это происходит либо при использовании идентификатора случая, обработка для которого определена глобально на уровне фазы, или с помощью следующего синтаксиса, который локально определяет обработку случая.

< Случай >{ < Алгоритм > < Алгоритм > < Алгоритм > ... < Внутренняя функция > < Внутренняя функция > ... }< Случай >

Синтаксис соответствует синтаксиску, описанному в глобальном блоке случаев.

Если обработка для случая задана локально, хотя в наличии есть и глобальная обработка случая, то локальная является приоритетной. Случаи, которые не заданы ни локально, ни глобально, игнорируются на данном шаге без каких-либо видимых реакций.

Глобальная обработка случая не действует автоматически в каждом шаге диалога, а только там, где она выбирается путем ввода вручную идентификатора случая.

Пример:

DIALOG{{{ abbruch open_window{ OPSW ECHO SCHRITTENDE }open_window }}}DIALOG

Обработка глобально заданного случая abbruch, локальное объявление и обработка случая open_window.


1.11.14.5  Блок управления шагами

В данном шаге в зависимости от последовательности задания шагов определяется двусторонняя очередность шагов для какой-либо фазы. См. определение шага (SCHRITTE).

Начинается ключевым словом

FOLGE{{

и заканчивается ключевым словом

}}FOLGE  .

Для каждого шага при выборе вносится запись следующего синтаксиса:

< Исходный шаг > < Альтернатива > < Конечный шаг >

< Исходный шаг >: Имя текущего шага или ключевое слово ALLE для всех шагов фазы. Запись с текущим именем шага имеет приоритет по сравнению с записью с ALLE при том же самом выборе (альтернативы).

< Выбор >: Целое число, с помощью которого выполняется нумерация различных возможностей определения конечных шагов в зависимости от исходного шага.

< Конечный шаг >: Следующий активируемый шаг.

Для всех непредставленных исходных шагов и альтернатив выбирается шаг в качестве конечного шага, который запланирован либо вручную с помощью алгоритма шага, либо автоматически с помощью своей последовательности объявления. Если шаг последовательности отсутствует, то фаза завершается и пользователь, сформировавший задание, получает телеграмму завершения фазы.

2  Отладчик диалога

Диалоговый инструментарий по запросу(требованию) запускает диалог отладчика, с помощью которого можно тестировать все диалоги, которые обрабатывает отладчик диалога, на уровне файлов управления диалогом. Функционал включает:

- Статистика (потребность в памяти)
- Списки (объявление и алгоритмы)
- Завершение и планирование диалогов
- Тестирование диалога

Диалог использует собственные окна и сам был создан с помощью диалогового инструментария.

3  Макросы диалога

С помощью специальных DIAT-алгоритмов (DIASTART, DIAENDE, FALLGEN, DIAIMPORT, DIAEXPORT, BEDVERERB) можно создавать макросы диалога, которые описывают наиболее часто повторяющиеся субдиалоги и которые могут использоваться каждым диалогом.


Например: Использование выпадающих меню для выбора альтернативы. Определение числа с помощью слайдера или полосы прокрутки. Построчное или постраничное редактирование текста. Управление контейнером изображений.

Существует набор макросов диалогов AWL, который непрерывно дополняется.

4  Алгоритмы последовательности управляющих команд

Следующие алгоритмы относятся к последовательностям управляющих команд, которые создаются с помощью редактора последовательности управляющих команд монитора последовательности управляющих команд.


4.1  Алгоритм синхронизации

Этот алгоритм имеет следующие функции:

1.) Устаналивается флаг синхронизации.
2.) Устаналивается флаг квитирования.
3.) Результат квитирования устанавливается в 0.
4.) Элемент данных QUIT.txt, при его наличии, становится пустой строкой.


Алгоритм имеет следующий синтаксис:

SYNC

SYNC: Сокращение(аббревиатура команды) для 'Синхронизировать последовательность'.


Каждый алгоритм проверяет флаг квитирования и квитирует свое выполнение, если он установлен. Внешний алгоритм передает обязанности по квитированию и выполнению какому-либо другому внешнему пользователю.

Затем он автоматически удаляется, таким образом, всегда выполняется квитированным только тот алгоритм, который следует сразу за алгоритмом SYNC. При квитировании флаг синхронизации удаляется. Ожидание квитирования, равно как и установка результатов квитирования, производится с помощью алгоритма ERWARTE.


4.2  Алгоритм ожидания

Этот алгоритм задерживает/останавливает последовательность, пока флаг синхронизации не будет удален. Удаление выполняется либо при квитировании алгоритма, который следует за алгоритмом SYNC, либо с помощью алгоритма BEFREIE.

Алгоритм имеет следующий синтаксис:

ERWARTE < Операнд[IN_DE] >

ERWARTE: Сокращение(аббревиатура) команды для 'Ожидать синхронизации'.


Параметры в вышеуказанной последовательности означают следующее:

1.) Переменная (элемент данных или индекс), которой присваивается успешный результат после квитирования. Неудача = "1" , Успех = "0" . Если флаг синхронизации удален с помощью алгоритма BEFREIE, то он определяет содержимое переменной.

Алгоритмы, ожидающие синхронизации с внешним пользователем, сообщают ему об этом в задании с помощью флага квитирования. Помеченные подобным образом алгоритмы должны быть квитированы пользователем с помощью следующего задания на синхронизацию:

SYDI < Имя диалога > < Результат квитирования > < Текст квитирования >

SYDI: Сокращение(аббревиатура) команды для 'Синхронизировать диалог'.

< Имя диалога >: Имя диалога, который дал команду синхронизации.

< Результат квитирования >
0 в случае успеха, != 0 при неудаче

< Текс квитирования > Текст длиной макс. 80 символов, который описывает результат.

4.3  Алгоритм освобождения

Этот алгоритм удаляет флаг синхронизации, передает результат синхронизации освобожденной последовательности и копирует текст в элемент данных QUIT.txt освобожденной последовательности, если в наличии есть элемент данных с таким именем.

Алгоритм имеет следующий синтаксис:

BEFREIE < Операнд[ST_DE] > < Операнд[IN_ST_DE] > < Операнд[ST] >

BEFREIE: Сокращение(аббревиатура) команды для 'Освободить последовательность от остановки синхронизации'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Идентификатор освобождаемой последовательности.
2.) Целое число. Результат синхронизации.
3.) Текст длиной макс. 80 символов, который описывает результат.


4.4  Алгоритм запуска последовательности

Этот алгоритм дает задание монитору последовательности управляющих команд на запуск известной ему последовательности управляющих команд. Алгоритм имеет следующий синтаксис:

FOLGESTART < Операнд[ST_DE] >

FOLGESTART: Сокращение(аббревиатура) команды для 'Запустить последовательность управляющих команд'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Идентификатор запускаемой последовательности.

4.5  Алгоритм завершения последовательности

Этот алгоритм дает задание монитору последовательности управляющих команд на асинхронное завершение известной ему последовательности управляющих команд. Если алгоритм касается текущей последовательности, то она сразу же завершается.

Алгоритм имеет следующий синтаксис:

FOLGEENDE < Операнд[ST_DE] >

FOLGEENDE: Сокращение(аббревиатура) команды для 'Завершить последовательность управляющих команд'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Идентификатор последовательности, которую необходимо завершить.

4.6  Алгоритм прерывания последовательности

Этот алгоритм дает задание монитору последовательности управляющих команд на прерывание текущей последовательности управляющих команд.

Алгоритм имеет следующий синтаксис:

FOLGEABBR

FOLGEABBR: Kommandokьrzel fьr 'Bedienfolge abbrechen'.

4.7  Алгоритм телеграмм в формате Ascii

Этот алгоритм отправляет телеграмму в формате Ascii конкретному пользователю. Телеграмма соответствует типу телеграммы MS_TYP(AUFTR) (см. ds_dias.d)

Алгоритм имеет следующий синтаксис:

ATELE < Операнд[IN_ST_DE] > < Операнд[ST_DE] >

ATELE: Сокращение(аббревиатура) команды для 'ASCII-телеграмма'.


Параметры в вышеуказанной последовательности означают следующее:

1.) Номер или имя пользователя получателя телеграммы. Имя или номер пользователя должны быть объявлены в списке внешних пользователей DIATа. Если этого не было сделано, то задание отклоняется.

2.) Содержимое телеграммы в виде строк с формате ASCII.

4.8  Внешний алгоритм

Этот алгоритм отправляет специфический текст в формате Ascii пользователю при указании информации о квитировании в связи с алгоритмом SYNC. Он представлен в протоколах с текстом пояснения. Телеграмма соответствует типу телеграммы MS_TYP(AUFTR) (см. ds_dias.d). При соответствующем запросе квитирования к пользователю он должен квитировать выполнение с помощью телеграммы SYDI, представленной под алгоритмом ожидания.

Алгоритм имеет следующий синтаксис:

EXAN < Операнд[ST_DE] > < Операнд[IN_ST_DE] > < Операнд[ST_DE] >

EXAN: Сокращение(аббревиатура) команды для 'Внешний алгоритм'.

или

EXANP < Операнд[ST_DE] > < Операнд[IN_ST_DE] > < Операнд[ST_DE] >

EXANP: Сокращение(аббревиатура) команды для 'Внешний алгоритм с набором параметров'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Текст описания, который представляет алгоритм в списках и протоколах за исключением отладчика и скрывает собственное содержимое телеграммы.

2.) Номер или имя пользователя получателя телеграммы. Имя или номер пользователя должны быть объявлены в списке внешних пользователей DIATа. Если этого не было сделано, то задание отклоняется.


3.) Содержимое телеграммы в виде строки в формате ASCII.

Алгоритм EXANP может использоваться только вместе с программами переключений, так как он имеет доступ к параметрам, которые задаются только при запуске программы переключения. Если отсутствует хотя бы один параметр или по меньшей мере один параметр имеет значение "-", то алгоритм EXANP не выполняется, однако производятся возможные действия по синхронизации (автоматическое освобождение от алгоритма ERWARTE). Алгоритм EXANP за пределами программ переключения не имеет силы. Заменяемые части обеих строк параметров 1 и 3 обозначаются с помощью следующего синтаксиса:

[< Номер параметра >] или [< Операнд[IN] >]

Пример:

EXANP "LADE BILD [0] IN MO:[1] WI:[2]" "5" "4711 0 3 [0]" EXANP "LADE BILD [i1] IN MO:[i2] WI:[i3]" "ZDM" "4711 0 3 [i1]"

< Номер параметра >: Отсчитанный с 0 текущий номер параметров, которые были переданы при запуске программы переключения. При выполнении алгоритма EXANP подстановочные знаки параметров заменяются/замещаются соответственными текущими параметрами.

При задании операнда[IN] содержимое индекса используется в качестве номера параметра при замещении подстановочного знака параметра текущим параметром.

Пример для алгоритма EXAN:

EXAN "LADE BILD KARLTAL IN MO:0 WI:3" "5" "4711 0 3 KARLTAL"

Этот алгоритм отправляет следующую телеграмму типа MS_TYP(AUFTR) пользователю с номером 5 :

4711 0 3 KARLTAL < Имя диалога > < Флаг квитирования > < Режим > < Пользователь > [ < Параметр > ]

Где:

< Имя диалога > : Идентификатор диалога, который представляет ту последовательность, которую выполнил алгоритм EXAN. Этот диалог(эта последовательность) ожидает в зависимости от < Флаг квитирования > квитирования выполнения с помощью телеграммы SYDI.

< Флаг квитирования > : Либо 'N' , если пользователь должен выполнить, а не квитировать, либо 'Q' , если пользователь должен квитировать выполнение с помощью телеграммы SYDI.

< Режим > : Режим (управления/моделирования), при котором должно быть выполнено задание.

< Пользователь > : Имя пользователя, который запустил последовательность управляющих команд.

< Параметр > : Параметр, дополнительно прикрепленный с помощью алгоритма внешних параметров.

4.9  Алгоритм внешних параметров

С помощью данного алгоритма внешнему алгоритму могут быть переданы дополнительные параметры. Это необходимо, например, для команд заданных значений, если заданное значение определяется в последовательности.

Алгоритм внешних параметров всегда относится только к первому внешнему алгоритму. Т.е. для каждой последующей передачи параметров должен быть написан собственный алгоритм внешних параметров.

Алгоритм имеет следующий синтаксис:

EXTPARA < Операнд[IN_DE] >

EXTPARA: Сокращение(аббревиатура) для 'Внешний алгоритм-параметр'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Переменная (элемент данных или индекс), содержимое которой должно быть передано внешнему алгоритму в качестве дополнительного параметра. При выполнении алгоритма EXAN параметр прикрепляется в конце телеграммы задания (см. "Внешний алгоритм").


4.10  Алгоритм протоколирования последовательности

Этот алгоритм имеет функцию только в рамках последовательности управлящих команд: вывод строки в протоколе выполнения для монитора последовательности управляющих команд, когда содержащая его(алгоритм) последовательность протоколируется.

Алгоритм имеет следующий синтаксис:

PROTO < Operand[ST] >

PROTO: Сокращение(аббревиатура) команды для 'Протоколировать строку'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Протоколируемая строка.

4.11  Алгоритм импорта параметров

Алгоритм импорта параметров служит в рамках программы переключений для импорта параметров из строки параметров программы переключений в индексы и элементы данных.

Алгоритм имеет следующий синтаксис:

PROGPARAM < Операнд[IN_DE] > < Операнд[IN_ST_DE] >

PROGPARAM: Сокращение(аббревиатура) команды для 'Импорт параметров программы'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Операнд, которому должен быть назначен параметр. Назначение производится по правилам арифметических алгоритмов.

2.) Номер параметра, который должен быть импортирован из строки параметров программы переключений.

Алгоритм импорта параметров может использоваться только вместе с программами переключений, так как он имеет доступ к параметрам, которые определяются только при запуске программы переключений. Алгоритм импорта параметров за пределами программы переключений не имеет силы.

4.12  Алгоритм квитирования

Алгоритм квитирования служит для отправки телеграмм квитирования (SYDI) пользователю. Телеграмма соответствует типу телеграмм MS_TYP(AUFTR) (см ds_diat.d)

Алгоритм имеет следующий синтаксис:

QUITTUSER < Операнд[ST_DE] >

QUITTUSER: Сокращение(аббревиатура) команды для 'Квитирование пользователю'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Строка с квитированием, которая должна быть отправлена пользователю.

4.13  Алгоритм пользователя

Этот алгоритм служит для запроса ввода данных пользователем. Управление диалогом ввода осуществляется монитором последовательности управляющих команд (см. "Описание монитора управляющих команд"). Последовательность управляющих команд должна быть остановлена до тех пор, пока не будет произведен запрошенный ввод данных.

Алгоритм имеет следующий синтаксис:

BEDIENER < Операнд[IN_ST_DE] > < Операнд[IN_DE] >

BEDIENER: Сокращение(аббревиатура) команды для 'Ввод данных пользователем'.

Параметры в вышеуказанной последовательности означают следующее:

1.) Текст запроса. Текст запроса передается монитору последовательности управляющих команд и отображается там при управлении диалогом ввода.

2.) Операнд, которому должен быть назначен результат.

5  Ввод внешних алгоритмов в последовательность

Последовательность образуется при редактировании в мониторе последовательности управляющих команд и/или при вводе внешних алгоритмов на основе управляющих действий Awl, которые выполняются внешним пользователем. Если задание для AWL, которое указано с помощью диалога управления, должно быть частью последовательности, то нормальное управление этим диалогом осуществляется в режиме "Задание последовательности управляющих команд". Затем соответствующая телеграмма внешнего алгоритма отправляется в монитор последовательности управляющих команд, который и включает эту телеграммву в режиме "EXTERN" в редактируемую последовательность.

Телеграмма внешнего алгоритма является телеграммой типа MS_TYP(AUFTR) и имеет следующее содержимое:

FLGDEF EXAN "< kt >""< user >""< tele >"

< kt >   : Текст описания внешнего алгоритма < user > : Номер или имя внешнего пользователя < tele > : Строка задания, которая запускает у внешнего пользователя соответствующее задание, которое описано в < kt >.


6  Описание телеграмм

Задания для DIAT и монитора последовательности управляющих команд поступают с помощью типов телеграмм

EXTDIA_Tele

AUFTR

Задания EXTDIA_Tele передают свои команды и параметры в элементе pst. Обычно они отправляются центральным диспетчером диалогов в диалоговый инструментарий.


Обрабатывается следующее pst-содержимое EXTDIA_Tele-заданий :

1) Запуск следующего свободного отладчика диалогов:

EXPA < Номер окна > < Номер пользователя > DBG

2) Запуск следующего свободного монитора последовательности управляющих команд:

EXPA < Номер окна > < Номер пользователя > * BFM

3) Запуск последовательности управляющих команд

EXPA < Номер окна > < Номер пользователя > * FLG < Идентификатор последовательности >

4) Останов последовательности управляющих команд

EXPA < Номер окна > < Номер пользователя  * FST < Идентификатор последовательности >

5) Смена режима моделирования

EXPA -1 < Номер пользователя > ~SIM

6) Смена пользователя

EXPA -1 < Номер пользователя > ~BED < Новое имя пользователя >

7) Смена режима записи (Recordmode)

EXPA -1 < Номер пользователя > ~REC




Задания AUFTR являются чисто строковыми заданиями(String) и могут быть отправлены любым пользователем в диалоговый инструментарий.

Обрабатывается следующее содержимое заданий AUFTR :

-- Запуск диалога для пользователя(User) на мониторе с макс. 4 начальными параметрами. (tn_int_dia)

STDI < Имя диалога > [ E< Номер режима > ] [ B< Пользователь > ] [ S< Сектор > ] < Относительный № АРМа > < Абсолютный № АРМа > < Относительный № графического сервера(XGS) > < Абсолютный № графического сервера(XGS) > < Относительный № монитора > < Абсолютный № монитора > < Файл управления диалогом > < User > дополнительно : < Подстрока1 > < Подстрока2 > < Подстрока3 > < Подстрока4 >

-- Запуск диалога из исходного диалога(источника) на мониторе с макс. 4 начальными параметрами. (tn_int_dia)

ISTD < Имя диалога > [ E< Номер режима > ] [ B< Пользователь > ] [ S< Сектор > ] < Относительный № АРМа > < Абсолютный № АРМа > < Относительный № графического сервера(XGS) > < Абсолютный № графического сервера(XGS) > < Относительный № монитора > < Абсолютный № монитора > < Файл управления диалогом > < User > < № корневого диалога > < № исходного диалога > < Имя исходного диалога > дополнительно : < Подстрока1 > < Подстрока2 > < Подстрока3 > < Подстрока4 >


-- Запуск последовательности управляющих команд для пользователя(User) на мониторе с макс. 3 начальными параметрами. (tn_int_dia)

STFG < Имя диалога > [ E< Номер режима > ] [ B< Пользователь > ] [ S< Сектор > ] < Относительный № АРМа > < Абсолютный № АРМа > < Относительный № графического сервера(XGS) > < Абсолютный № графического сервера(XGS) > < Относительный № монитора > < Абсолютный № монитора > < Файл управления диалогом для тела последовательности> < User > < Идентификатор последовательности > < Флаг протокола > < Файл управления диалогом для фрагмента последовательности > дополнительно : < Подстрока2 > < Подстрока3 > < Подстрока4 >

-- Запуск программы переключений для пользователя(User) на мониторе с макс. 3 начальными параметрами. (tn_int_dia)

STPG < Имя диалога > [ E< Номер режима > ] [ B< Пользователь > ] [ S< Сектор > ] < Относительный № АРМа > < Абсолютный № АРМа > < Относительный № графического сервера(XGS) > < Абсолютный № графического сервера(XGS) > < Относительный № монитора > < Абсолютный № монитора > < Файл управления диалогом для тела последовательности > < User > < Идентификатор последовательности > < Флаг протокола > < Индекс параметра программы переключений > < Файл управления диалогом для фрагмента последовательности > дополнительно : < Подстрока2 > < Подстрока3 > < Подстрока4 >

-- Пробная перевод(преобразование) диалога для пользователя(User) на мониторе с макс. 3 начальными параметрами. (tn_int_dia)

UBFG < Имя диалога > <  Файл управления диалогом для тела последовательности > < User > < Файл управления диалогом для фрагмента последовательности > дополнительно : < Подстрока2 > < Подстрока3 > < Подстрока4 >



-- Планирование диалога для пользователя(User) на мониторе с макс. 4 начальными параметрами. (tn_int_dia)

PLDI < Имя диалога > < Файл управления диалогом > < User > дополнительно : < Подстрока1 > < Подстрока2 > < Подстрока3 > < Подстрока4 >

-- Планирование последовательности управляющих команд для пользователя(User) на мониторе с макс. 3 начальными параметрами. (tn_int_dia)

PLFG < Имя диалога > < Файл управления диалогом для тела последовательности > < User > < Ижентификатор последовательности > < Файл управления диалогом для фрагмента последовательности > дополнительно : < Подстрока2 > < Подстрока3 > < Подстрока4 >

-- Запуск запланированного диалога на мониторе с макс. 4 начальными параметрами. (tn_sys_dia)

SPDI < Имя диалога > [ E< Номер режима > ] [ B< Пользователь > ] [ S< Сектор > ] < Относительный № АРМа > < Абсолютный № АРМа > < Относительный № графического сервера(XGS) > < Абсолютный № графического сервера(XGS) > < Относительный № монитора > < Абсолютный № монитора > дополнительно : < Подстрока1 > < Подстрока2 > < Подстрока3 > < Подстрока4 >



-- Запуск запланированного диалога на монитроре из исходного диалога с макс. 4 начальными параметрами. (tn_sys_dia)

ISPD < Имя диалога > [ E< Номер режима > ] [ B< Пользователь > ] [ S< Сектор > ] < Относительный № АРМа > < Абсолютный № АРМа > < Относительный № графического сервера(XGS) > < Абсолютный № графического сервера(XGS) > < Относительный № монитора > < Абсолютный № монитора > < № корневого диалога > < № исходного диалога> < Имя исходного диалога > дополнительно : < Подстрока1 > < Подстрока2 > < Подстрока3 > < Подстрока4 >

-- Запуск запланированной последовательности управляющих команд на мониторе с макс. 4 начальными параметрами. (tn_sys_dia)

SPFG < Имя диалога > [ E< Номер режима > ] [ B< Пользователь > ] [ S< Сектор > ] < Относительный № АРМа > < Абсолютный № АРМа > < Относительный № графического сервера(XGS) > < Абсолютный № графического сервера(XGS) > < Относительный № монитора > < Абсолютный № монитора > < Флаг протокола > дополнительно : < Подстрока1 > < Подстрока2 > < Подстрока3 > < Подстрока4 >

-- Запуск запланированной программы переключений на мониторе с макс. 4 начальными параметрами. (tn_sys_dia)

SPPG < Имя диалога > [ E< Номер режима > ] [ B< Пользователь > ] [ S< Сектор > ] < Относительный № АРМа > < Абсолютный № АРМа > < Относительный № графического сервера(XGS) > < Абсолютный № графического сервера(XGS) > < Относительный № монитора > < Абсолютный № монитора > < Флаг протокола > < Индекс параметра программы переключений > дополнительно : < Подстрока1 > < Подстрока2 > < Подстрока3 > < Подстрока4


-- Прерывание диалога. (tn_sys_dia)

ABDI < Имя диалога >

-- Прерывание всех диалогов пользователя. (tn_sys_dia)

ABAD < User >

-- Внутреннее прерывание диалога. (tn_sys_dia)

IABD < Имя диалога > < Опция >

-- Запуск фазы диалога для какого-либо диалога. (tn_sys_dia)

PHDI < Имя диалога > < Имя фазы >

-- Отмена планирования ранее запланированного диалога. (tn_sys_dia)

APDI < Имя диалога >

-- Синхронизация с пользователем. (tn_sys_dia)

SYDI < Имя диалога > < Результат квитирования > < Текст квитирования >

-- Сброс управения диалогом. (tn_sys_dia)

DVRS < Имя диалога >

-- Остановить диалог. (tn_sys_dia)

HADI < Имя диалога >

-- Продолжить диалог. (tn_sys_dia)

CODI < Имя диалога >

-- Пошаговое продолжение диалога. (tn_sys_dia)

STEP < Имя диалога >

-- Включить протоколирование для диалога. (tn_sys_dia)

PEIN < Имя диалога >

-- Отключить протоколирование для диалога. (tn_sys_dia)

PAUS < Имя диалога >


-- Поэлементная передача данных какому-либо набору данных какого-либо диалога. (tn_dad_dia)

DADI < Имя диалога > < Имя набора данных >

сколь угодно часто повторяется: |< Строка >

-- Передача введенных пользователем данных какой-либо последовательности управляющих команд. (tn_dad_dia)

DABF < Имя диалога > |< Строка >

-- Случай ввода данных для диалога. (tn_dad_dia)

FADI < Dialogmatch > < Действие > < Строка >

-- Данные для конкретного случая ввода данных для диалога. (tn_dad_dia)

DFDI < Dialogmatch > < Имя набора данных >

сколь угодно часто повторяется: |< Строка >

-- Поэлементная передача результатов достоверизации какому-либо набору данных какого-либо диалога. (tn_pld_dia)

PLDS < Имя диалога > < Имя набора данных > сколь угодно часто повторяется: |< Строка >

-- Передача результатов достоверизации какому-либо элементу данных какого-либо набора данных какого-либо диалога. (tn_pld_dia)

PLDE < Имя диалога > < Имя набора данных > < Имя элемента данных > |< Строка > [|< Строка >]

-- Включение алгоритма в последовательность управляющих команд. (tn_bfm_dia)

FLGDEF < Строка алгоритма >

-- Вывод строки протокола в списке протоколов. (tn_bfm_dia)

BFMPROT < Строка протокола >

-- Сообщение о том, что последовательность управляющих команд началась с того, что ждет алгоритма освобождения и что она была освобождена. (tn_bfm_dia)

FLGSYNC < Имя диалога > < Опция >

-- Запуск последовательности управляющих команд из диалога или последовательности с указанием пожелания квитирования. (tn_bfm_dia)

BFMSTART < User > < Имя диалога > < Флаг квитирования > < Идентификатор последовательности > [ E< Номер режима > ] [ B< Пользователь > ]

-- Остановка последовательности управляющих команд из диалога или последовательности с указанием пожелания квитирования. (tn_bfm_dia)

BFMENDE < User > < Имя диалога > < Флаг квитирования > < Идентификатор последовательности >

-- Приостановка последовательности управляющих команд из диалога без квитирования. (tn_bfm_dia)

BFMHALT < User > < Имя диалога > < Флаг квитирования > < Идентификатор последовательности >

-- Продолжение последовательности управляющих команд из диалога без квитирования. (tn_bfm_dia)

BFMCONT < User > < Имя диалога > < Флаг квитирования > < Идентификатор последовательности >

-- Запуск программы переключения с указанием пожелания квитирования и передача параметров. (tn_bfm_dia)

BFMPROG < User > < Имя диалога > < Флаг квитирования > < Идентификатор программы > [ E< Номер режима > ] [ B< Пользователь > ] < Строка параметров >


Строка параметров имеет следующую форму:

< Параметр >#< Параметр >#....#< Параметр >

Параметр имеет либо форму

-       (Dummy),

либо не равен какой-либо последовательности символов -


- и способствует тому, что алгоритм, который использует этот параметр, не выполняется.


Следующее задание отправляется в строку функций текстового окна для запуска диалога текстового окна (AUFTR) :

STXF B< Пользователь > < относительный № АРМа > < абсолютный № АРМа > < относительный № графического севера (XGS) > < абсолютный № графического севера (XGS) > < относительный № монитора > < абсолютный № монитора > < класс текста справки >
- < заголовок раздела (тема) >
